<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jocoboy&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-06T15:46:29.056Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jocoboy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity自定义天空盒</title>
    <link href="http://yoursite.com/2020/01/06/Unity-Graphics-Skybox/"/>
    <id>http://yoursite.com/2020/01/06/Unity-Graphics-Skybox/</id>
    <published>2020-01-06T13:02:25.000Z</published>
    <updated>2020-01-06T15:46:29.056Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Skybox is a six-sided cube that Unity draws behind all graphics in the Scene.</span><br></pre></td></tr></table></figure><p>一个天空盒是一个六面立方体，会将游戏场景中的所有图形包裹。</p><a id="more"></a><h2 id="自定义天空盒"><a href="#自定义天空盒" class="headerlink" title="自定义天空盒"></a>自定义天空盒</h2><h3 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h3><ol><li>创建与天空盒六个面相对于的六个纹理，将它们放在项目的<code>Assets</code>文件夹中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Make six Textures that correspond to each of the six sides of the skybox, and put them into your</span><br><span class="line">Project’s Assets folder.</span><br></pre></td></tr></table></figure></li></ol><img src="/images/skybox/skybox_textures.png" alt="skybox textures"><ol start="2"><li>对于每个纹理，需要将包裹模式从<code>Repeat</code>更改为<code>Clamp</code>。如果不这样做，边缘上的颜色将不匹配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">For each Texture, you need to change the wrap mode from Repeat to Clamp.</span><br><span class="line">If you don’t do this, colors on the edges do not match up.</span><br></pre></td></tr></table></figure></li></ol><img src="/images/skybox/wrap_mode.png" alt="wrap mode"><ol start="3"><li><p>从菜单栏中选择<code>Assets &gt; Create &gt; Material</code>以创建新材质。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create a new Material. To do this, choose Assets &gt; Create &gt; Material from the menu bar.</span><br></pre></td></tr></table></figure></li><li><p>在<code>Inspector</code>面板的顶部选择<code>Shader</code>下拉选单，然后选择<code>Skybox/6 Sided</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select the Shader drop-down and choose Skybox/6 Sided.</span><br></pre></td></tr></table></figure></li><li><p>将6个纹理分配给材质中的每个纹理字段。为此，可将每个纹理从<code>Project</code>面板拖放到相应的字段上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assign the six Textures to each Texture slot in the Material. </span><br><span class="line">To do this, you can drag each Texture from the Project View onto the corresponding slots.</span><br></pre></td></tr></table></figure></li></ol><img src="/images/skybox/skybox_inspector.png" alt="skybox inspector"><ol start="6"><li>最后，将天空盒分配给当前场景，须执行以下操作：<ul><li>在菜单栏中选择<code>Window &gt; Rendering &gt; Lighting Settings</code>。</li><li>在随后出现的窗口中选择Scene选项卡。</li><li>将新的天空盒材质拖放到<code>Skybox</code>字段。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">To assign the skybox to the Scene you’re working on:</span><br><span class="line"></span><br><span class="line">- From the menu bar, choose Window &gt; Rendering &gt; Lighting Settings.</span><br><span class="line">- In the window that appears, select the Scene tab.</span><br><span class="line">- Drag the new Skybox Material to the Skybox slot.</span><br></pre></td></tr></table></figure></li></ul></li></ol><img src="/images/skybox/skybox_application.png" alt="skybox application"><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://docs.unity3d.com/Manual/HOWTO-UseSkybox.html" target="_blank" rel="noopener">How do I Make a Skybox?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A Skybox is a six-sided cube that Unity draws behind all graphics in the Scene.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个天空盒是一个六面立方体，会将游戏场景中的所有图形包裹。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
      <category term="C#" scheme="http://yoursite.com/categories/Unity/C/"/>
    
    
      <category term="Unity-Graphics" scheme="http://yoursite.com/tags/Unity-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>Unity脚本生命周期</title>
    <link href="http://yoursite.com/2020/01/04/Unity-Script-Lifecycle/"/>
    <id>http://yoursite.com/2020/01/04/Unity-Script-Lifecycle/</id>
    <published>2020-01-04T15:07:14.000Z</published>
    <updated>2020-01-06T16:57:52.499Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Running a Unity script executes a number of event functions in a predetermined order.</span><br></pre></td></tr></table></figure><p>一个Unity脚本中的事件函数将会以预定顺序执行。</p><a id="more"></a><h2 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>下图总结了脚本生命周期中事件函数的排序和重复出现情况。</p><img src="/images/lifecycle/monobehaviour_flowchart.svg" alt="monobehaviour flowchart"><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><strong>Awake</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function is always called before any Start functions and also just after a prefab is instantiated.</span><br></pre></td></tr></table></figure><p>  此函数将在预制件实例化之后调用，并始终优先于任何Start函数。</p></li><li><p><strong>OnEnable</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This function is called just after the object is enabled. This happens when a MonoBehaviour </span><br><span class="line">instance is created, such as when a level is loaded or a GameObject with the script component </span><br><span class="line">is instantiated.</span><br></pre></td></tr></table></figure><p>  此函数将在启用对象后立即调用。在创建MonoBehaviour实例时（例如加载关卡或一个携带脚本组件的游戏对象被实例化时）会执行此调用。</p></li><li><p><strong>Reset</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reset is called to initialize the script’s properties when it is first attached to the object</span><br><span class="line">and also when the Reset command is used.</span><br></pre></td></tr></table></figure><p>  此函数将在脚本首次被附加到对象上以及使用<code>Reset</code>命令时调用，以初始化脚本的属性。</p></li><li><p><strong>Start</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Start is called before the first frame update only if the script instance is enabled.</span><br></pre></td></tr></table></figure><p>  此函数将紧跟Awake函数调用，确切来说是在第一此帧更新前并且此时脚本实例已被启用。</p></li><li><p><strong>FixedUpdate</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FixedUpdate is often called more frequently than Update. </span><br><span class="line">It can be called multiple times per frame, if the frame rate is low and it may not be called </span><br><span class="line">between frames at all if the frame rate is high. </span><br><span class="line">All physics calculations and updates occur immediately after FixedUpdate. </span><br><span class="line">When applying movement calculations inside FixedUpdate, you do not need to multiply your values </span><br><span class="line">by Time.deltaTime. </span><br><span class="line">This is because FixedUpdate is called on a reliable timer, independent of the frame rate.</span><br></pre></td></tr></table></figure><p>  调用FixedUpdate的频度常常超过Update。如果帧率很低，可以每帧调用该函数多次；如果帧率很高，可能在帧之间完全不调用该函数。在FixedUpdate之后将立即进行所有物理计算和更新。在FixedUpdate内应用运动计算时，无需将值乘以 <code>Time.deltaTime</code>。这是因为FixedUpdate的调用基于可靠的计时器（独立于帧率）。</p></li><li><p><strong>Update</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Update is called once per frame. It is the main workhorse function for frame updates.</span><br></pre></td></tr></table></figure><p>  此函数是帧更新的主函数，受当前渲染物体和机器性能影响，被调用的时间间隔不固定。</p></li><li><p><strong>Coroutines</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Normal coroutine updates are run after the Update function returns. A coroutine is a function </span><br><span class="line">that can suspend its execution (yield) until the given YieldInstruction finishes. </span><br><span class="line">Different uses of Coroutines:</span><br><span class="line"></span><br><span class="line">- yield The coroutine will continue after all Update functions have been called on the next frame.</span><br><span class="line">- yield WaitForSeconds Continue after a specified time delay, after all Update functions have </span><br><span class="line">been called for the frame</span><br><span class="line">- yield WaitForFixedUpdate Continue after all FixedUpdate has been called on all scripts</span><br><span class="line">- yield WWW Continue after a WWW download has completed.</span><br><span class="line">- yield StartCoroutine Chains the coroutine, and will wait for the MyFunc coroutine to complete first.</span><br></pre></td></tr></table></figure><p>  Update函数返回后将运行正常协程更新。协程是一个可暂停执行(yield)直到给定的YieldInstruction达到完成状态的函数。协程的不同用法：</p><ul><li><strong>yield</strong> 协程将在下一帧上调用所有Update函数后，继续执行。</li><li><strong>yield WaitForSeconds</strong> 协程将在指定的时间延迟后（并且当前帧所有Update函数执行后），继续执行。</li><li><strong>yield WaitForFixedUpdate</strong> 协程将在所有脚本的FixedUpdate函数执行后，继续执行。</li><li><strong>yield WWW</strong> 协程将在WWW资源下载完成后，继续执行。</li><li><strong>yield StartCoroutine</strong> 协程将在指定协程执行后，继续执行。</li></ul></li><li><p><strong>LateUpdate</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LateUpdate is called once per frame, after Update has finished.</span><br></pre></td></tr></table></figure><p>  此函数将紧跟Update函数调用，通常用于伴随逻辑的跟踪。</p></li><li><p><strong>OnApplicationPause</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is called at the end of the frame where the pause is detected, effectively between the </span><br><span class="line">normal frame updates. One extra frame will be issued after OnApplicationPause is called to </span><br><span class="line">allow the game to show graphics that indicate the paused state.</span><br></pre></td></tr></table></figure><p>  在帧的结尾处调用此函数（在正常帧更新之间有效检测到暂停）。在调用OnApplicationPause之后，将发出一个额外帧，从而允许游戏显示图形来指示暂停状态。</p></li><li><p><strong>OnApplicationQuit</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This function is called on all game objects before the application is quit. </span><br><span class="line">In the editor it is called when the user stops playmode.</span><br></pre></td></tr></table></figure><p>  此函数将在应用退出之前调用，例如在Editor中再次点击<code>Play</code>按钮关闭播放模式。</p></li><li><p><strong>OnDisable</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function is called when the behaviour becomes disabled or inactive.</span><br></pre></td></tr></table></figure><p>  此函数将在行为被禁用或处于非活动状态时调用，例如OnApplicationQuit函数调用之后。</p></li><li><p><strong>OnDestroy</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This function is called after all frame updates for the last frame of the object’s existence </span><br><span class="line">(the object might be destroyed in response to Object.Destroy or at the closure of a scene).</span><br></pre></td></tr></table></figure><p>  此函数将在对象存在的最后一帧完成所有帧更新之后调用，可能应<code>Object.Destroy</code>函数要求或在场景关闭时销毁该对象。</p></li></ul><h3 id="函数执行顺序测试"><a href="#函数执行顺序测试" class="headerlink" title="函数执行顺序测试"></a>函数执行顺序测试</h3><p>（以下测试<strong>不包含</strong>协程函数）<br>为一个Cube物体添加Lifecycle脚本组件。</p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Simple demo for script lifecycle .</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lifecycle</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"Function : Awake() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"Function : OnEnable() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"Function : Reset() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"Function : Start() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Time.time &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Function : FixedUpdate() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private void OnMouseDown()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     Debug.Log("Function : OnMouseDown() " + "Time : " + Time.time + " Object.name : " + this.name);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Time.time &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Function : Update() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Time.time &lt; <span class="number">0.1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Function : LateUpdate() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private void OnGUI()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if (Time.time &lt; 0.1)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         Debug.Log("Function : OnGUI() " + "Time : " + Time.time + " Object.name : " + this.name);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnApplicationPause</span>(<span class="params"><span class="keyword">bool</span> pause = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pause)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Function : OnApplicationPause() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnApplicationQuit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"Function : OnApplicationQuit() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"Function : OnDisable() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">"Function : OnDestroy() "</span> + <span class="string">"Time : "</span> + Time.time + <span class="string">" Object.name : "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><img src="/images/lifecycle/lifecycle_demo.png" alt="lifecycle demo"><h4 id="测试反馈"><a href="#测试反馈" class="headerlink" title="测试反馈"></a>测试反馈</h4><p>控制台输出结果表明，运行场景时在Editor中点击<code>Pause</code>按钮将不会调用OnApplicationPause函数。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://docs.unity3d.com/Manual/ExecutionOrder.html" target="_blank" rel="noopener">Order of Execution for Event Functions</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Running a Unity script executes a number of event functions in a predetermined order.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个Unity脚本中的事件函数将会以预定顺序执行。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
      <category term="C#" scheme="http://yoursite.com/categories/Unity/C/"/>
    
    
      <category term="Unity-Scripting" scheme="http://yoursite.com/tags/Unity-Scripting/"/>
    
  </entry>
  
</feed>
