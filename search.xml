<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unity自定义天空盒]]></title>
    <url>%2F2020%2F01%2F06%2FUnity-Graphics-Skybox%2F</url>
    <content type="text"><![CDATA[1A Skybox is a six-sided cube that Unity draws behind all graphics in the Scene. 一个天空盒是一个六面立方体，会将游戏场景中的所有图形包裹。 自定义天空盒6-sided准备6张TIFF/TIF格式(具有跨平台性)的方位局部图，1024×1024px。 创建步骤 创建与天空盒六个面相对应的六个纹理，将它们放在项目的Assets文件夹中。12Make six Textures that correspond to each of the six sides of the skybox, and put them into yourProject’s Assets folder. 对于每个纹理，需要将包裹模式从Repeat更改为Clamp。如果不这样做，边缘上的颜色将不匹配。12For each Texture, you need to change the wrap mode from Repeat to Clamp.If you don’t do this, colors on the edges do not match up. 从菜单栏中选择Assets &gt; Create &gt; Material以创建新材质。 1Create a new Material. To do this, choose Assets &gt; Create &gt; Material from the menu bar. 在Inspector面板的顶部选择Shader下拉选单，然后选择Skybox/6 Sided。 1Select the Shader drop-down and choose Skybox/6 Sided. 将6个纹理分配给材质中的每个纹理字段。为此，可将每个纹理从Project面板拖放到相应的字段上。 12Assign the six Textures to each Texture slot in the Material. To do this, you can drag each Texture from the Project View onto the corresponding slots. 最后，将天空盒分配给当前场景，须执行以下操作： 在菜单栏中选择Window &gt; Rendering &gt; Lighting Settings。 在随后出现的窗口中选择Scene选项卡。 将新的天空盒材质拖放到Skybox字段。12345To assign the skybox to the Scene you’re working on:- From the menu bar, choose Window &gt; Rendering &gt; Lighting Settings.- In the window that appears, select the Scene tab.- Drag the new Skybox Material to the Skybox slot. panoramic准备1张png格式的（360°/720°）全景图，2048×1024px/4096×2048px。 创建步骤步骤1~3及步骤6同6-sided。 在Inspector面板的顶部选择Shader下拉选单，然后选择Skybox/Panoramic。 1Select the Shader drop-down and choose Skybox/Panoramic. 为材质选择一个球状纹理。 1Assign a Spherical Texture to the Material. 官方文档How do I Make a Skybox?]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Unity-Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本生命周期]]></title>
    <url>%2F2020%2F01%2F04%2FUnity-Script-Lifecycle%2F</url>
    <content type="text"><![CDATA[1Running a Unity script executes a number of event functions in a predetermined order. 一个Unity脚本中的事件函数将会以预定顺序执行。 脚本生命周期流程图下图总结了脚本生命周期中事件函数的排序和重复出现情况。 说明 Awake: 1This function is always called before any Start functions and also just after a prefab is instantiated. 此函数将在预制件实例化之后调用，并始终优先于任何Start函数。 OnEnable: 123This function is called just after the object is enabled. This happens when a MonoBehaviour instance is created, such as when a level is loaded or a GameObject with the script component is instantiated. 此函数将在启用对象后立即调用。在创建MonoBehaviour实例时（例如加载关卡或一个携带脚本组件的游戏对象被实例化时）会执行此调用。 Reset: 12Reset is called to initialize the script’s properties when it is first attached to the objectand also when the Reset command is used. 此函数将在脚本首次被附加到对象上以及使用Reset命令时调用，以初始化脚本的属性。 Start: 1Start is called before the first frame update only if the script instance is enabled. 此函数将紧跟Awake函数调用，确切来说是在第一此帧更新前并且此时脚本实例已被启用。 FixedUpdate: 1234567FixedUpdate is often called more frequently than Update. It can be called multiple times per frame, if the frame rate is low and it may not be called between frames at all if the frame rate is high. All physics calculations and updates occur immediately after FixedUpdate. When applying movement calculations inside FixedUpdate, you do not need to multiply your values by Time.deltaTime. This is because FixedUpdate is called on a reliable timer, independent of the frame rate. 调用FixedUpdate的频度常常超过Update。如果帧率很低，可以每帧调用该函数多次；如果帧率很高，可能在帧之间完全不调用该函数。在FixedUpdate之后将立即进行所有物理计算和更新。在FixedUpdate内应用运动计算时，无需将值乘以 Time.deltaTime。这是因为FixedUpdate的调用基于可靠的计时器（独立于帧率）。 Update: 1Update is called once per frame. It is the main workhorse function for frame updates. 此函数是帧更新的主函数，受当前渲染物体和机器性能影响，被调用的时间间隔不固定。 Coroutines： 12345678910Normal coroutine updates are run after the Update function returns. A coroutine is a function that can suspend its execution (yield) until the given YieldInstruction finishes. Different uses of Coroutines:- yield The coroutine will continue after all Update functions have been called on the next frame.- yield WaitForSeconds Continue after a specified time delay, after all Update functions have been called for the frame- yield WaitForFixedUpdate Continue after all FixedUpdate has been called on all scripts- yield WWW Continue after a WWW download has completed.- yield StartCoroutine Chains the coroutine, and will wait for the MyFunc coroutine to complete first. Update函数返回后将运行正常协程更新。协程是一个可暂停执行(yield)直到给定的YieldInstruction达到完成状态的函数。协程的不同用法： yield 协程将在下一帧上调用所有Update函数后，继续执行。 yield WaitForSeconds 协程将在指定的时间延迟后（并且当前帧所有Update函数执行后），继续执行。 yield WaitForFixedUpdate 协程将在所有脚本的FixedUpdate函数执行后，继续执行。 yield WWW 协程将在WWW资源下载完成后，继续执行。 yield StartCoroutine 协程将在指定协程执行后，继续执行。 LateUpdate: 1LateUpdate is called once per frame, after Update has finished. 此函数将紧跟Update函数调用，通常用于伴随逻辑的跟踪。 OnApplicationPause 123This is called at the end of the frame where the pause is detected, effectively between the normal frame updates. One extra frame will be issued after OnApplicationPause is called to allow the game to show graphics that indicate the paused state. 在帧的结尾处调用此函数（在正常帧更新之间有效检测到暂停）。在调用OnApplicationPause之后，将发出一个额外帧，从而允许游戏显示图形来指示暂停状态。 OnApplicationQuit: 12This function is called on all game objects before the application is quit. In the editor it is called when the user stops playmode. 此函数将在应用退出之前调用，例如在Editor中再次点击Play按钮关闭播放模式。 OnDisable: 1This function is called when the behaviour becomes disabled or inactive. 此函数将在行为被禁用或处于非活动状态时调用，例如OnApplicationQuit函数调用之后。 OnDestroy: 12This function is called after all frame updates for the last frame of the object’s existence (the object might be destroyed in response to Object.Destroy or at the closure of a scene). 此函数将在对象存在的最后一帧完成所有帧更新之后调用，可能应Object.Destroy函数要求或在场景关闭时销毁该对象。 函数执行顺序测试（以下测试不包含协程函数）为一个Cube物体添加Lifecycle脚本组件。 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using UnityEngine;/// &lt;summary&gt;/// Simple demo for script lifecycle ./// &lt;summary&gt;public class Lifecycle : MonoBehaviour&#123; private void Awake() &#123; Debug.Log("Function : Awake() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void OnEnable() &#123; Debug.Log("Function : OnEnable() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void Reset() &#123; Debug.Log("Function : Reset() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void Start() &#123; Debug.Log("Function : Start() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void FixedUpdate() &#123; if (Time.time &lt; 0.1) &#123; Debug.Log("Function : FixedUpdate() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; // private void OnMouseDown() // &#123; // Debug.Log("Function : OnMouseDown() " + "Time : " + Time.time + " Object.name : " + this.name); // &#125; private void Update() &#123; if (Time.time &lt; 0.1) &#123; Debug.Log("Function : Update() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; private void LateUpdate() &#123; if (Time.time &lt; 0.1) &#123; Debug.Log("Function : LateUpdate() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; // private void OnGUI() // &#123; // if (Time.time &lt; 0.1) // &#123; // Debug.Log("Function : OnGUI() " + "Time : " + Time.time + " Object.name : " + this.name); // &#125; // &#125; private void OnApplicationPause(bool pause = true) &#123; if (pause) &#123; Debug.Log("Function : OnApplicationPause() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; private void OnApplicationQuit() &#123; Debug.Log("Function : OnApplicationQuit() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void OnDisable() &#123; Debug.Log("Function : OnDisable() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; public void OnDestroy() &#123; Debug.Log("Function : OnDestroy() " + "Time : " + Time.time + " Object.name : " + this.name); &#125;&#125; 测试结果 测试反馈控制台输出结果表明，运行场景时在Editor中点击Pause按钮将不会调用OnApplicationPause函数。 官方文档Order of Execution for Event Functions]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Unity-Scripting</tag>
      </tags>
  </entry>
</search>
