<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无向图的割点与桥]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%E4%B8%8E%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[无向图求割点基本概念 割点：无向连通图中，如果删除某点后，图的连通性被破坏，则称该点为割点 Tarjan算法应用src: luogu 题意：给定无向图G。求总割点数，并按字典序输出所有割点。 题解：利用Tarjan算法思想。 当前节点为树根时，如果子树不止一棵，则该点为割点 当前节点不是树根时，如果无向边(u, v)为树边(父子边)且low[v]&gt;=dfn[u] (不成环)，则该点为割点 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// #include &lt;bits\stdc++.h&gt;#include &lt;iostream&gt;using namespace std;const int N = 20001;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int to; int next; &#125;; node edge[N * 10]; int head[N]; int tot; int low[N]; int dfn[N]; bool vis[N]; int cutPointNum; bool cutPoint[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); void findSCC(); void Tarjan(int, int); void printCutPoint();&#125;;void Graph::init()&#123; tot = 0; cutPointNum = 0; for (int i = 1; i &lt;= vertexNum; i++) &#123; head[i] = -1; low[i] = 0; dfn[i] = 0; vis[i] = 0; cutPoint[i] = false; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum * 2; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; edge[i].to = v; edge[i].next = head[u]; head[u] = i; i++; edge[i].to = u; edge[i].next = head[v]; head[v] = i; &#125;&#125;void Graph::findSCC()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (!dfn[i]) &#123; Tarjan(i, i); &#125; &#125;&#125;void Graph::Tarjan(int u, int root)&#123; int children = 0; low[u] = dfn[u] = ++tot; vis[u] = true; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (!dfn[v]) &#123; Tarjan(v, root); low[u] = min(low[u], low[v]); if (u != root &amp;&amp; low[v] &gt;= dfn[u]) &#123; cutPoint[u] = true; &#125; if (u == root) &#123; children++; &#125; &#125; else if (vis[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (u == root &amp;&amp; children &gt;= 2) &#123; cutPoint[root] = true; &#125;&#125;void Graph::printCutPoint()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (cutPoint[i]) &#123; cutPointNum++; &#125; &#125; cout &lt;&lt; cutPointNum &lt;&lt; endl; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (cutPoint[i]) &#123; cout &lt;&lt; i &lt;&lt; ' '; &#125; &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Graph G(n, m); G.init(); G.addEdge(); G.findSCC(); G.printCutPoint(); return 0;&#125; 无向图求桥基本概念 桥：无向连通图中，如果删除某边后，图的连通性被破坏，则称该边为桥 Tarjan算法应用src: uva 题意：给定无向图G。求总桥数，并按字典序输出所有桥。 题解：利用Tarjan算法思想。 当且仅当无向边(u, v)为树边(父子边)且low[v]&gt;dfn[u] (不成环)时，该边为桥 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// #include &lt;bits\stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200001;class Graph&#123;private: int vertexNum; struct node &#123; int from; int to; int next; &#125;; node edge[N]; int head[N]; int cnt; int tot; int low[N]; int dfn[N]; bool vis[N]; int cutEdgeNum; int cutEdge[N];public: Graph(int n) : vertexNum(n) &#123;&#125; void init(); void addEdge(); void findSCC(); void Tarjan(int, int); void printCutEdge();&#125;;void Graph::init()&#123; cnt = 0; tot = 0; cutEdgeNum = 0; for (int i = 0; i &lt; vertexNum; i++) &#123; head[i] = -1; low[i] = 0; dfn[i] = 0; vis[i] = 0; cutEdge[i] = false; &#125;&#125;void Graph::addEdge()&#123; for (int i = 0; i &lt; vertexNum; i++) &#123; int u, n, v; cin &gt;&gt; u; cin.get(); cin.get(); cin &gt;&gt; n; cin.get(); for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; v; edge[cnt].from = u; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++; &#125; &#125;&#125;void Graph::findSCC()&#123; for (int i = 0; i &lt; vertexNum; i++) &#123; if (!dfn[i]) &#123; Tarjan(i, 0); &#125; &#125;&#125;void Graph::Tarjan(int u, int parent)&#123; low[u] = dfn[u] = ++tot; vis[u] = true; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (v == parent) continue; if (!dfn[v]) &#123; Tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v] &gt; dfn[u]) &#123; cutEdge[++cutEdgeNum] = i; &#125; &#125; else if (vis[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125;&#125;void Graph::printCutEdge()&#123; for (int i = 1; i &lt;= cutEdgeNum; i++) &#123; int j = cutEdge[i]; if (edge[j].from &gt; edge[j].to) &#123; swap(edge[j].from, edge[j].to); &#125; &#125; sort(cutEdge + 1, cutEdge + 1 + cutEdgeNum, [&amp;](int a, int b) &#123;if(edge[a].from != edge[b].from) return edge[a].from &lt; edge[b].from; return edge[a].to &lt; edge[b].to; &#125;); cout &lt;&lt; cutEdgeNum &lt;&lt; " critical links" &lt;&lt; endl; for (int i = 1; i &lt;= cutEdgeNum; i++) &#123; int j = cutEdge[i]; cout &lt;&lt; edge[j].from &lt;&lt; " - " &lt;&lt; edge[j].to &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int n; while (cin &gt;&gt; n) &#123; Graph G(n); G.init(); G.addEdge(); G.findSCC(); G.printCutEdge(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂]]></title>
    <url>%2F2019%2F06%2F20%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[基本概念 单位矩阵：主对角线元素全为1，其余元素全为0的矩阵，充当数乘运算中的1 矩阵乘积：$C(c_{ij}) = A(a_{ik}) * B(b_{kj})$, 其中$c_{ij}= \displaystyle\sum_{k=1}^{n}a_{ik} * b_{kj}$ 快速幂：计算$a^n$时，将指数n转化为二进制数，记第i位为$k_i$，则$n = \displaystyle\sum_{i=1}^{n}k_i*2^{i-1}$，以此将O(n)的复杂度降至O(logn) 应用场景k步可达路径方案数src: HDU 题意：给定有向图G，给出若干组(A,B,k)。问你从A到B恰好经过k个顶点的方案数。 题解：矩阵快速幂模板题。 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1000;template &lt;class T, int N&gt;class Matrix&#123;private: int n; T value[N][N];public: Matrix(bool isIdentityMatrix = false) : n(N) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; value[i][j] = T(0); &#125; &#125; if (isIdentityMatrix) for (int i = 0; i &lt; n; i++) &#123; value[i][i] = T(1); &#125; &#125; Matrix operator+(const Matrix &amp;b) const &#123; Matrix&lt;T, N&gt; ret; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) ret.value[i][j] = (value[i][j] + b.value[i][j]) % mod; return ret; &#125; Matrix operator*(const Matrix &amp;b) const &#123; Matrix&lt;T, N&gt; ret; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++) ret.value[i][j] = (ret.value[i][j] + value[i][k] * b.value[k][j]) % mod; return ret; &#125; Matrix &amp;operator%(const int mod) &#123; return *this; &#125; void setValue(int u, int v) &#123; value[u][v] = 1; &#125; T getValue(int u, int v) &#123; return this-&gt;value[u][v]; &#125;&#125;;template &lt;class T&gt;T fpow(T a, LL n)&#123; T ret(true); while (n) &#123; ret = ret * (n &amp; 1 ? a : T(1)) % mod; a = a * a % mod; n &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; int n, m, t; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n + m)) &#123; Matrix&lt;LL, 25&gt; a, b; for (int i = 0; i &lt; m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; a.setValue(u, v); &#125; for (cin &gt;&gt; t; t &gt; 0; t--) &#123; int u, v, k; cin &gt;&gt; u &gt;&gt; v &gt;&gt; k; b = fpow(a, k); cout &lt;&lt; b.getValue(u, v) &lt;&lt; endl; &#125; &#125; return 0;&#125; Fibonacci数列第k项src: POJ 题意：求Fibonacci数列第k项的后四位(1≤k≤1000000000)。 题解：根据递推式$F_n=F_{n-1}+F_{n-2}$构造二阶矩阵作为底数。 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int mod = 10000;template &lt;class T, int N&gt;class Matrix&#123;private: int n; T value[N][N];public: Matrix(bool isIdentityMatrix = false) : n(N) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; value[i][j] = T(0); &#125; &#125; if (isIdentityMatrix) for (int i = 0; i &lt; n; i++) &#123; value[i][i] = T(1); &#125; &#125; Matrix operator+(const Matrix &amp;b) const &#123; Matrix&lt;T, N&gt; ret; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) ret.value[i][j] = (value[i][j] + b.value[i][j]) % mod; return ret; &#125; Matrix operator*(const Matrix &amp;b) const &#123; Matrix&lt;T, N&gt; ret; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++) ret.value[i][j] = (ret.value[i][j] + value[i][k] * b.value[k][j]) % mod; return ret; &#125; Matrix &amp;operator%(const int mod) &#123; return *this; &#125; void setValue(int u, int v) &#123; value[u][v] = 1; &#125; T getValue(int u, int v) &#123; return this-&gt;value[u][v]; &#125;&#125;;template &lt;class T&gt;T fpow(T a, LL n)&#123; T ret(true); while (n) &#123; ret = ret * (n &amp; 1 ? a : T(1)) % mod; a = a * a % mod; n &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; int n; while (cin &gt;&gt; n &amp;&amp; n != -1) &#123; Matrix&lt;LL, 2&gt; a, b; a.setValue(0, 0); a.setValue(0, 1); a.setValue(1, 0); b = fpow(a, n); cout &lt;&lt; b.getValue(0, 1) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Number Theory</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配]]></title>
    <url>%2F2019%2F06%2F10%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Hungary算法 基本概念 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径。 增广路：从一个未匹配点出发，沿着交替路途经另一个未匹配点的路径。图中，9-&gt;4-&gt;8-&gt;1-&gt;6-&gt;2就是一条增广路。增广路的非匹配边比匹配边多一条。 基本思想通过寻找增广路，不断交换增广路中的匹配边与非匹配边的身份(相当于添加一条匹配边)，直到找不到增广路为止。 应用场景用于解决无权二分图最大匹配问题。 src: HDU 题意：给定无权二分图，求最大匹配数。 题解：Hungary算法模板题。 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits\stdc++.h&gt;using namespace std;const int N = 501;class Graph&#123;private: int edgeNum; int lvertexNum; int rvertexNum; int maxMatch; int matrix[N][N]; bool vis[N]; int lvertex[N]; int rvertex[N];public: Graph(int m, int ln, int rn) : edgeNum(m), lvertexNum(ln), rvertexNum(rn) &#123;&#125; void init(); void addEdge(); void Hungary(); bool find(int);&#125;;void Graph::init()&#123; maxMatch = 0; memset(matrix, 0, sizeof(matrix)); memset(lvertex, 0, sizeof(lvertex)); memset(rvertex, 0, sizeof(rvertex));&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; matrix[u][v] = 1; &#125;&#125;void Graph::Hungary()&#123; for (int i = 1; i &lt;= lvertexNum; i++) &#123; if (!lvertex[i]) &#123; memset(vis, 0, sizeof(vis)); if (find(i)) &#123; maxMatch++; &#125; &#125; &#125; cout &lt;&lt; maxMatch &lt;&lt; endl;&#125;bool Graph::find(int u)&#123; for (int v = 1; v &lt;= rvertexNum; v++) &#123; if (matrix[u][v] &amp;&amp; !vis[v]) &#123; vis[v] = true; if (!rvertex[v] || find(rvertex[v])) &#123; lvertex[u] = v; rvertex[v] = u; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int m, ln, rn; while (cin &gt;&gt; m &amp;&amp; m) &#123; cin &gt;&gt; ln &gt;&gt; rn; Graph G(m, ln, rn); G.init(); G.addEdge(); G.Hungary(); &#125; return 0;&#125; KM算法基本思想 初始化时，将左侧顶点赋值为最大权重，右侧顶点赋值为0。 用Hungary算法为左侧第i个顶点匹配最大权重边。 若匹配失败，遍历左右两侧顶点，在已被匹配的左侧顶点与未被匹配的右侧顶点之间寻找最小代价，并根据左右两侧顶点匹配情况降低左侧顶点权重或增加右侧顶点权重，重复步骤(2)，直到该点匹配成功。 若匹配成功，记录匹配顶点，重复步骤(2)，直到左侧所有顶点都被匹配。 应用场景用于解决带权二分图完美匹配下的最优匹配问题。 src: HDU 题意：给定带权二分图，求最大匹配权。 题解：KM算法模板题。注意此题卡cin。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits\stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 301;class Graph&#123;private: int vertexNum; int optMatch; int matrix[N][N]; int rvertex[N]; int lexp[N]; int rexp[N]; bool lvis[N]; bool rvis[N];public: Graph(int n) : vertexNum(n) &#123;&#125; void init(); void addEdge(); void KM(); bool find(int);&#125;;void Graph::init()&#123; optMatch = 0; for (int i = 1; i &lt;= vertexNum; i++) &#123; rvertex[i] = 0; lexp[i] = INF; rexp[i] = 0; for (int j = 1; j &lt;= vertexNum; j++) &#123; lexp[i] = max(matrix[i][j], lexp[i]); &#125; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; for (int j = 1; j &lt;= vertexNum; j++) &#123; cin &gt;&gt; matrix[i][j]; &#125; &#125;&#125;void Graph::KM()&#123; init(); for (int i = 1; i &lt;= vertexNum; i++) &#123; while (true) &#123; int slack = INF; memset(lvis, 0, sizeof(lvis)); memset(rvis, 0, sizeof(rvis)); if (find(i)) break; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (lvis[i]) &#123; for (int j = 1; j &lt;= vertexNum; j++) &#123; if (!rvis[j]) &#123; slack = min(slack, lexp[i] + rexp[j] - matrix[i][j]); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (lvis[i]) &#123; lexp[i] -= slack; &#125; if (rvis[i]) &#123; rexp[i] += slack; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= vertexNum; i++) &#123; optMatch += matrix[rvertex[i]][i]; &#125; cout &lt;&lt; optMatch &lt;&lt; endl;&#125;bool Graph::find(int u)&#123; lvis[u] = true; for (int v = 1; v &lt;= vertexNum; v++) &#123; if (!rvis[v] &amp;&amp; lexp[u] + rexp[v] == matrix[u][v]) &#123; rvis[v] = true; if (!rvertex[v] || find(rvertex[v])) &#123; rvertex[v] = u; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(NULL); int n; while (cin &gt;&gt; n) &#123; Graph G(n); G.init(); G.addEdge(); G.KM(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>Hungary</tag>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-适定性问题]]></title>
    <url>%2F2019%2F06%2F04%2Fk-%E9%80%82%E5%AE%9A%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[k-sat问题基本概念给定若干集合，每个集合有若干元素，每个集合元素个数不超过k个。给出从每个集合中选取元素的约束条件以及目标方案，判可行性。若可行，求可行解。 当k=1时，每个集合中元素的个数至多为1，问题的答案显而易见。当k=2时，假定每个集合中元素有且仅有2个，且2个元素不允许同时被取出，即为2-sat问题的一般情景。当k&gt;=3时，k-sat问题是NP-Complete问题，无法在多项式时间内解决，不作讨论。 应用场景2-sat判可行性src: HDU 题意：给定n个集合，每个集合中有2个元素，给定集合间的m对矛盾关系。判从2n个元素中取n个元素的可行性。 题解：2-sat裸题。将元素之间的一对矛盾关系转化为顶点之间的一条无向连边，建图后Tarjan算法判图连通性即可。注意此题卡cin。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits\stdc++.h&gt;using namespace std;const int N = 2001;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int to; int next; &#125;; node edge[N * 500]; int head[N]; stack&lt;int&gt; st; int tot; int low[N]; int dfn[N]; bool vis[N]; int SCCNum; int color[N]; //vector&lt;int&gt; SCC[N];public: Graph(int n, int m) : vertexNum(n &lt;&lt; 1), edgeNum(m &lt;&lt; 1) &#123;&#125; void init(); void addEdge(); bool findSCC(); void Tarjan(int); //void print();&#125;;void Graph::init()&#123; tot = 0; SCCNum = 0; for (int i = 0; i &lt; vertexNum; i++) &#123; head[i] = -1; low[i] = 0; dfn[i] = 0; vis[i] = 0; &#125;&#125;void Graph::addEdge()&#123; for (int i = 0; i &lt; edgeNum; i++) &#123; int u, v, a1, a2, c1, c2; cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; c1 &gt;&gt; c2; u = (a1 &lt;&lt; 1) + c1; v = (a2 &lt;&lt; 1) + c2; edge[i].to = v ^ 1; edge[i].next = head[u]; head[u] = i++; edge[i].to = u ^ 1; edge[i].next = head[v]; head[v] = i; &#125;&#125;bool Graph::findSCC()&#123; for (int i = 0; i &lt; vertexNum; i++) &#123; if (!dfn[i]) &#123; Tarjan(i); &#125; &#125; for (int i = 0; i &lt; vertexNum; i += 2) &#123; if (color[i] == color[i + 1]) &#123; return false; &#125; &#125; return true;&#125;void Graph::Tarjan(int u)&#123; low[u] = dfn[u] = ++tot; st.push(u); vis[u] = true; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (vis[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (low[u] == dfn[u]) &#123; int v; SCCNum++; do &#123; v = st.top(); st.pop(); vis[v] = false; //SCC[SCCNum].push_back(v); color[v] = SCCNum; &#125; while (u != v); &#125;&#125;/*void Graph::print()&#123; cout &lt;&lt; SCCNum &lt;&lt; endl; for (int i = 1; i &lt;= SCCNum; i++) &#123; for (int j = 0; j &lt; SCC[i].size(); j++) &#123; cout &lt;&lt; SCC[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;*/int main()&#123; ios::sync_with_stdio(false); cin.tie(NULL); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; Graph G(n, m); G.init(); G.addEdge(); cout &lt;&lt; (G.findSCC() ? "YES" : "NO") &lt;&lt; endl; //G.print(); &#125; return 0;&#125; 2-sat求可行解src: codeforces 题意：给定n串数字字符，所有数字不超过m。给出一种标记操作，带上标记的数字字典序将小于一般数字。判若干次操作后可使字符串升序的可行性。若可行，输出可行解。 题解：对于相同位置的字符，标记时存在若干对矛盾关系。依次建边后Tarjan算法判图连通性的同时，记录各连通分支中顶点元素的拓扑序列，依据相邻顶点拓扑序输出标记方案。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;bits\stdc++.h&gt;using namespace std;const int N = 200001;vector&lt;int&gt; let[N];class Graph&#123;private: int vertexNum; //int edgeNum; struct node &#123; int to; int next; &#125;; node edge[N]; int head[N]; int cnt; stack&lt;int&gt; st; int tot; int low[N]; int dfn[N]; bool vis[N]; int sum; int topo[N]; int SCCNum; int color[N]; //vector&lt;int&gt; SCC[N];public: Graph(int n) : vertexNum(n &lt;&lt; 1) &#123;&#125; void init(); void addEdge(int, int); void findSCC(); void Tarjan(int); //void print();&#125;;void Graph::init()&#123; sum = 0; cnt = 0; tot = 0; SCCNum = 0; for (int i = 0; i &lt; vertexNum; i++) &#123; head[i] = -1; low[i] = 0; dfn[i] = 0; vis[i] = 0; &#125;&#125;void Graph::addEdge(int u, int v)&#123; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;&#125;void Graph::findSCC()&#123; for (int i = 0; i &lt; vertexNum; i++) &#123; if (!dfn[i]) &#123; Tarjan(i); &#125; &#125; bool flag = true; for (int i = 0; i &lt; vertexNum &amp;&amp; flag; i++) &#123; if (color[i] == color[i + 1]) &#123; flag = false; &#125; &#125; if (flag) &#123; puts("Yes"); vector&lt;int&gt; ans; for (int i = 0; i &lt; vertexNum; i += 2) &#123; if (topo[i] &lt; topo[i +1]) &#123; ans.push_back((i &gt;&gt; 1) + 1); &#125; &#125; cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto v : ans) &#123; cout &lt;&lt; v &lt;&lt; " "; &#125; &#125; else &#123; puts("No"); &#125;&#125;void Graph::Tarjan(int u)&#123; low[u] = dfn[u] = ++tot; st.push(u); vis[u] = true; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (vis[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (low[u] == dfn[u]) &#123; int v; SCCNum++; do &#123; v = st.top(); st.pop(); vis[v] = false; color[v] = SCCNum; topo[v] = ++sum; //SCC[SCCNum].push_back(v); &#125; while (u != v); &#125;&#125;/*void Graph::print()&#123; cout &lt;&lt; SCCNum &lt;&lt; endl; for (int i = 1; i &lt;= SCCNum; i++) &#123; for (int j = 0; j &lt; SCC[i].size(); j++) &#123; cout &lt;&lt; SCC[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;*/int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; int len; cin &gt;&gt; len; for (int j = 1; j &lt;= len; j++) &#123; int x; cin &gt;&gt; x; let[i].push_back(x); &#125; &#125; Graph G(m); G.init(); for (int i = 1; i &lt;= n - 1; i++) &#123; bool flag = false; int mlen = min(let[i].size(), let[i + 1].size()); for (int j = 0; j &lt; mlen; j++) &#123; int u = let[i][j] - 1; int v = let[i + 1][j] - 1; if (u != v) &#123; if (u &lt; v) &#123; G.addEdge(u &lt;&lt; 1 ^ 1, v &lt;&lt; 1 ^ 1); G.addEdge(v &lt;&lt; 1, u &lt;&lt; 1); &#125; else &#123; G.addEdge(u &lt;&lt; 1 ^ 1, u &lt;&lt; 1); G.addEdge(v &lt;&lt; 1, v &lt;&lt; 1 ^ 1); &#125; flag = true; break; &#125; &#125; if (!flag &amp;&amp; let[i].size() &gt; let[i + 1].size()) &#123; return 0 * puts("No"); &#125; &#125; G.findSCC(); //G.print(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>2-sat</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强连通分量]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%2F</url>
    <content type="text"><![CDATA[特殊的图存储结构前向星前向星是一种特殊的边集数组，其中存储着每一条边的起点、终点、权值。借助head数组构造前向星之前，必须将每一条边按起点从小到大排序(如果起点相同就按终点从小到大排序)，时间复杂度较高。 链式前向星在前向星的基础上，向边集数组中引入next属性，代表与当前边同起点的下一条边的存储位置，以避免排序。链式前向星与邻接表类似，不同之处在于，邻接表越先输入的边离结点越近而越早遍历，而链式前向星越先输入的边离结点越远而越晚遍历。 Tarjan算法基本思想基于深度优先遍历思想。 将有向图中寻找强连通分量转化为搜索树中寻找搜索子树 引入数组dfn，作为某点的时间戳(搜索次序编号) 引入数组low，作为某点在搜索树中最小搜索子树的根结点 遍历每一个顶点，借助栈记录顶点访问顺序 遍历链式前向星每一条边，记边的起点为u，终点为v 如果顶点v未被访问，继续搜索，搜索结束后，low[u]=min(low[u],low[v]) 如果顶点v已被访问并且顶点u还在栈内，low[u]=min(low[u],dfn[v]) 如果dfn[u]=low[u]，则顶点u为强连通分量的根结点，将v退栈直到u=v 应用场景用于求解有向图中的所有强连通分量。 src: codeforces 题意：给定有向图，并给出每个顶点的权值。求通过顶点将所有强连通分量联系在一起的最小代价和对应方案数。 题解：Tarjan算法模板题。将所有强连通分量联系在一起，即寻找每个强连通分量中权值最小的顶点，并求它们的和。权值最小的顶点每重复出现一次，对应方案数就会加一，运用乘法计数原理可求得对应方案数。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits\stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const int N = 100001;long long w[N], sum, total = 1;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int to; int next; &#125;; node edge[N * 3]; int head[N]; stack&lt;int&gt; st; int tot; int low[N]; int dfn[N]; bool vis[N]; //int SCCNum; //vector&lt;int&gt; SCC[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); void findSCC(); void Tarjan(int); //void print();&#125;;void Graph::init()&#123; tot = 0; //SCCNum = 0; for (int i = 1; i &lt;= vertexNum; i++) &#123; head[i] = -1; low[i] = 0; dfn[i] = 0; vis[i] = 0; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; edge[i].to = v; edge[i].next = head[u]; head[u] = i; &#125;&#125;void Graph::findSCC()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (!dfn[i]) &#123; Tarjan(i); &#125; &#125; cout &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; total &lt;&lt; endl;&#125;void Graph::Tarjan(int u)&#123; low[u] = dfn[u] = ++tot; st.push(u); vis[u] = true; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (vis[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (low[u] == dfn[u]) &#123; int v; //SCCNum++; int minn = INF, k = 0; do &#123; v = st.top(); st.pop(); vis[v] = false; if (minn &gt; w[v]) &#123; k = 1; minn = w[v]; &#125; else if (minn == w[v]) &#123; k++; &#125; //SCC[SCCNum].push_back(v); &#125; while (u != v); sum += minn; total = total * k % mod; &#125;&#125;/*void Graph::print()&#123; cout &lt;&lt; SCCNum &lt;&lt; endl; for (int i = 1; i &lt;= SCCNum; i++) &#123; for (int j = 0; j &lt; SCC[i].size(); j++) &#123; cout &lt;&lt; SCC[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;*/int main()&#123; int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; cin &gt;&gt; m; Graph G(n, m); G.init(); G.addEdge(); G.findSCC(); //G.print(); return 0;&#125; Kosaraju算法基本思想基于深度优先遍历思想。 首先对原图进行dfs并将出栈顺序逆序得到拓扑序列 然后将原图的每一条边反向得到反图，按照步骤(1)生成的拓扑序列顺序对反图进行dfs染色，染成同色的子图就是一个强连通分量 如果把每个强连通分量缩点，并按每个强连通分量求得的顺序标记缩点，那么这个顺序就是强连通分量缩点后形成的DAG的拓扑序列 应用场景用于求解有向图中的所有强连通分量。 src: POJ 题意：给定有向图。问你有多少个点可以被其他所有点访问到。 题解：Kosaraju算法模板题。正反两次dfs找到所有强连通分量后，将每个强连通分量缩点染色，然后统计每个缩点的出度。若有且只有一个出度为0的缩点，则答案为该缩点所对应的强连通分量中顶点的个数，否则答案为0。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//#include &lt;bits\stdc++.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int N = 10001;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int to; int next; &#125;; node edge[N * 5]; node redge[N * 5]; int head[N]; int rhead[N]; stack&lt;int&gt; topo; int color[N]; int outDegree[N]; bool vis[N]; int SCCNum; //vector&lt;int&gt; SCC[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addedge(); void findSCC(); void dfs(int); void rdfs(int); //void print();&#125;;void Graph::init()&#123; SCCNum = 0; for (int i = 1; i &lt;= vertexNum; i++) &#123; head[i] = -1; rhead[i] = -1; color[i] = 0; outDegree[i] = 0; vis[i] = false; &#125;&#125;void Graph::addedge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; edge[i].to = v; edge[i].next = head[u]; head[u] = i; redge[i].to = u; redge[i].next = rhead[v]; rhead[v] = i; &#125;&#125;void Graph::findSCC()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (!vis[i]) &#123; dfs(i); &#125; &#125; for (int i = 1; i &lt;= vertexNum; i++) &#123; vis[i] = false; &#125; while (!topo.empty()) &#123; int i = topo.top(); topo.pop(); if (!vis[i]) &#123; SCCNum++; rdfs(i); &#125; &#125; for (int u = 1; u &lt;= vertexNum; u++) &#123; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (color[u] != color[v]) &#123; outDegree[color[u]]++; &#125; &#125; &#125; int tot = 0, num = -1, ans = 0; for (int i = 1; i &lt;= SCCNum; i++) &#123; if (!outDegree[i]) &#123; tot++; num = i; &#125; &#125; if (tot == 1) &#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (color[i] == num) &#123; ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;void Graph::dfs(int u)&#123; vis[u] = true; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (!vis[v]) &#123; dfs(v); &#125; &#125; topo.push(u);&#125;void Graph::rdfs(int u)&#123; vis[u] = true; color[u] = SCCNum; //SCC[SCCNum].push_back(u); for (int i = rhead[u]; i != -1; i = redge[i].next) &#123; int v = redge[i].to; if (!vis[v]) &#123; rdfs(v); &#125; &#125;&#125;/*void Graph::print()&#123; cout &lt;&lt; SCCNum &lt;&lt; endl; for (int i = 1; i &lt;= SCCNum; i++) &#123; for (int j = 0; j &lt; SCC[i].size(); j++) &#123; cout &lt;&lt; SCC[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;*/int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Graph G(n, m); G.init(); G.addedge(); G.findSCC(); //G.print(); return 0;&#125; Gabow算法基本思想基于深度优先遍历思想。 优化Tarjan算法，利用二号栈取代dfn和low数组求强连通分量的根结点 遍历有向图每一个顶点，借助一号栈记录顶点访问顺序 遍历链式前向星每一条边，记边的起点为u，终点为v 如果顶点v未被访问，继续搜索 如果顶点v已被访问并且没有被删除，维护二号栈未构成环的结点(即删除二号栈中构成环的结点) 如果二号栈的顶元素等于u，则顶点u为强连通分量的根结点，将v退栈直到u=v 应用场景用于求解有向图中的所有强连通分量。 src: codeforces 题意：给定有向图，并给出每个顶点的权值。求通过顶点将所有强连通分量联系在一起的最小代价和对应方案数。 题解：Gabow算法模板题。将所有强连通分量联系在一起，即寻找每个强连通分量中权值最小的顶点，并求它们的和。权值最小的顶点每重复出现一次，对应方案数就会加一，运用乘法计数原理可求得对应方案数。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits\stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const int N = 100001;long long w[N], sum, total = 1;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int to; int next; &#125;; node edge[N * 3]; int head[N]; stack&lt;int&gt; st; int tot; stack&lt;int&gt; st2; int dfn[N]; bool vis[N]; //int SCCNum; //vector&lt;int&gt; SCC[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); void findSCC(); void Gabow(int); //void print();&#125;;void Graph::init()&#123; tot = 0; //SCCNum = 0; for (int i = 1; i &lt;= vertexNum; i++) &#123; head[i] = -1; dfn[i] = 0; vis[i] = false; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; edge[i].to = v; edge[i].next = head[u]; head[u] = i; &#125;&#125;void Graph::findSCC()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (!dfn[i]) &#123; Gabow(i); &#125; &#125; cout &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; total &lt;&lt; endl;&#125;void Graph::Gabow(int u)&#123; st.push(u); dfn[u] = ++tot; st2.push(u); for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (!dfn[v]) &#123; Gabow(v); &#125; else if (!vis[v]) &#123; while (dfn[st2.top()] &gt; dfn[v]) &#123; st2.pop(); &#125; &#125; &#125; if (st2.top() == u) &#123; int v; st2.pop(); //SCCNum++; int minn = INF, k = 0; do &#123; v = st.top(); st.pop(); vis[v] = true; //SCC[SCCNum].push_back(v); if (minn &gt; w[v]) &#123; k = 1; minn = w[v]; &#125; else if (minn == w[v]) &#123; k++; &#125; &#125; while (u != v); sum += minn; total = total * k % mod; &#125;&#125;/*void Graph::print()&#123; cout &lt;&lt; SCCNum &lt;&lt; endl; for (int i = 1; i &lt;= SCCNum; i++) &#123; for (int j = 0; j &lt; SCC[i].size(); j++) &#123; cout &lt;&lt; SCC[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;*/int main()&#123; int n, m; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; cin &gt;&gt; m; Graph G(n, m); G.init(); G.addEdge(); G.findSCC(); //G.print(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>Kosaraju</tag>
        <tag>Gabow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最优二叉树]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Huffman算法基本思想基于贪心思想。 以权值为w1,w2…wn的n个结点构成n棵二叉树，其中每棵二叉树仅有一个权值为wi的根结点 选取两颗根结点权值最小的树作为左右子树构造一棵新二叉树，并置新二叉树根结点权值为左右子树上根结点的权值之和 将合并的两棵二叉树从森林中删除，同时将新二叉树加入森林 重复步骤(2)和(3)，直到森林中只剩一棵二叉树 应用 给定n个结点的权值，求最优二叉树(注意贪心思想，n个结点权值的给出顺序不同，最终生成的最优二叉树也不同)。 测试样例: 1283 5 7 8 11 14 23 29 输出结果: 1234567891011121314150 3 8 -1 -11 5 8 -1 -12 7 9 -1 -13 8 9 -1 -14 11 10 -1 -15 14 11 -1 -16 23 12 -1 -17 29 13 -1 -18 8 10 0 19 15 11 2 310 19 12 4 811 29 13 5 912 41 14 6 1013 58 14 7 1114 100 -1 12 13 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 101;class Graph&#123;private: struct node &#123; int weight; int parent; int l_son; int r_son; &#125;; node tree[N];public: void init(int); void Huffman(int); void select(int, int &amp;, int &amp;); void update(int, int, int); void print(int);&#125;;void Graph::init(int n)&#123; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tree[i].weight; &#125; for (int i = 0; i &lt; 2 * n - 1; i++) &#123; tree[i].parent = -1; tree[i].l_son = -1; tree[i].r_son = -1; &#125;&#125;void Graph::update(int parent, int l_son, int r_son)&#123; tree[l_son].parent = parent; tree[r_son].parent = parent; tree[parent].l_son = l_son; tree[parent].r_son = r_son; tree[parent].weight = tree[l_son].weight + tree[r_son].weight;&#125;void Graph::select(int n, int &amp;l_son, int &amp;r_son)&#123; for (int i = 0; i &lt; n; i++) &#123; if (tree[i].parent == -1) &#123; l_son = i; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (tree[i].parent == -1 &amp;&amp; tree[l_son].weight &gt; tree[i].weight) &#123; r_son = i; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; if (tree[j].parent == -1 &amp;&amp; j != l_son) &#123; r_son = j; break; &#125; &#125; for (int j = 0; j &lt; n; j++) &#123; if (tree[j].parent == -1 &amp;&amp; j != l_son &amp;&amp; tree[r_son].weight &gt; tree[j].weight) &#123; r_son = j; &#125; &#125;&#125;void Graph::Huffman(int n)&#123; init(n); for (int i = n; i &lt; 2 * n - 1; i++) &#123; int l, r; select(i, l, r); update(i, l, r); &#125;&#125;void Graph::print(int n)&#123; cout &lt;&lt; left; for (int i = 0; i &lt; n * 2 - 1; i++) &#123; cout &lt;&lt; setw(10) &lt;&lt; i; cout &lt;&lt; setw(10) &lt;&lt; tree[i].weight; cout &lt;&lt; setw(10) &lt;&lt; tree[i].parent; cout &lt;&lt; setw(10) &lt;&lt; tree[i].l_son; cout &lt;&lt; setw(10) &lt;&lt; tree[i].r_son &lt;&lt; endl; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; Graph G; G.Huffman(n); G.print(n); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>Huffman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序与关键路径]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[DAG拓扑排序 给定G=&lt;V,E,W&gt;，G为无环有向图，顶点个数为N 找到G中入度为0的顶点并输出 删除该点的所有连边，重复步骤(1)，直到G中无入度为0的顶点 若输出顶点个数小于N，则证明G中有回路，没有关键路径 AOE网关键路径基本概念定义： AOE网中从起点到终点具有最大路径长度的路径。 特征属性： 事件——AOE网中的顶点 活动——AOE网中的边 $ES(i)$和$LS(i)$——事件$i$最早和最晚开始时间 $EF(i)$和$LF(i)$——事件$i$最早和最晚完成时间 $ES(i,j)$和$LS(i,j)$——活动$(i,j)$最早和最晚开始时间 $EF(i,j)$和$LF(i,j)$——活动$(i,j)$最早和最晚完成时间 $SL(i,j)$——活动$(i,j)$最晚开始(完成)时间与最早开始(完成)时间的差 公式： $ES(1) = 0, ES(i) = max( ES(j) + w_{ji} | &lt;i,j&gt; ∈ E )$ $LF(n) = ES(n), LF(i) = min( LF(j) - w_{ij} | &lt;i,j&gt; ∈ E )$ $ES(i,j) = ES(i), EF(i,j) = ES(i) + w_{ij}$ $LF(i,j) = LF(j), LS(i,j) = LF(j) - w_{ij}$ $SL(i,j) = LS(i,j) - ES(i,j) = LF(i,j) - EF(i,j)$ 基本思想 借助链式前向星建立AOE网 遍历链式前向星每个结点，找到AOE网的拓扑序列并将其存入栈内，同时更新VE[i]最大值，此过程借助队列实现 逆拓扑序遍历链式前向星，同时更新VL[i]最小值，此过程借助栈实现 遍历链式前向星每个结点，计算E[i]和L[i]，若二者相等，则为关键路径上的关键活动 应用 给定AOE网，求关键路径及其长度，注意关键路径可能不止一条(此处略去序列化操作)。 测试样例: 123456789101112131415169 151 2 31 3 21 4 42 3 02 5 43 4 23 5 43 6 44 7 55 6 05 7 35 9 66 8 37 8 18 9 1 输出结果: 123456131 22 52 33 55 9 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 101;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int to; int next; int w; &#125;; node edge[N]; int head[N]; int inDegree[N]; stack&lt;int&gt; topo; int VE[N]; int VL[N]; int E[N]; int L[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); void topoSort(); void CriticalPath();&#125;;void Graph::init()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; inDegree[i] = 0; head[i] = -1; VE[i] = 0; VL[i] = 0; E[i] = 0; L[i] = 0; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; inDegree[v]++; edge[i].to = v; edge[i].next = head[u]; head[u] = i; edge[i].w = w; &#125;&#125;void Graph::topoSort()&#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= vertexNum; i++) &#123; if (!inDegree[i]) &#123; q.push(i); &#125; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); topo.push(u); for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; if (!--inDegree[v]) &#123; q.push(v); &#125; VE[v] = max(VE[v], VE[u] + w); &#125; &#125;&#125;void Graph::CriticalPath()&#123; topoSort(); cout &lt;&lt; VE[vertexNum] &lt;&lt; endl; for (int i = 1; i &lt;= vertexNum; i++) &#123; VL[i] = VE[vertexNum]; &#125; while (!topo.empty()) &#123; int u = topo.top(); topo.pop(); for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; VL[u] = min(VL[u], VL[v] - w); &#125; &#125; for (int u = 1; u &lt;= vertexNum; u++) &#123; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; int w = edge[i].w; E[i] = VE[u]; L[i] = VL[v] - w; if (E[i] == L[i]) &#123; cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; &#125; &#125; &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Graph G(n, m); G.init(); G.addEdge(); G.CriticalPath(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>Toposort</tag>
        <tag>Critical Path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2F2019%2F05%2F17%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Kruskal算法基本思想基于贪心思想，借助并查集实现。 给定G=&lt;V,E,W&gt;，顶点个数为N 引入集合T，将G中非环边按权从小到大排序，取边e1加入T中 检查e2与e1是否构成回路，若构成回路则舍弃，否则将e2也加入T中 重复步骤(3)，直到生成树的边为N-1 应用场景用于稀疏图找最小生成树。 src: POJ 题意：给定无向带权图G，G中可能存在平行边。问你最小生成树所有边的权值和。 题解：Kruskal算法模板题，注意平行边可能权值相同，不要使用set。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 51;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int u; int v; int w; node(int u, int v, int w) : u(u), v(v), w(w) &#123;&#125; node(); friend bool operator&lt;(node a, node b) &#123; return a.w &lt; b.w; &#125; &#125;; multiset&lt;node&gt; edge; int pre[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); int find(int); bool unite(int, int); void addEdge(); int Kruskal();&#125;;void Graph::init()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; pre[i] = i; &#125;&#125;int Graph::find(int x)&#123; return x == pre[x] ? x : pre[x] = find(pre[x]);&#125;bool Graph::unite(int x, int y)&#123; int fx = find(x); int fy = find(y); if (fx != fy) &#123; pre[fx] = pre[fy]; return true; &#125; return false;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge.insert(node(u, v, w)); &#125;&#125;int Graph::Kruskal()&#123; int minWeight = 0; init(); for (multiset&lt;node&gt;::iterator it = edge.begin(); it != edge.end(); it++ /*auto e : edge*/) &#123; node e = *it; if (unite(e.u, e.v)) &#123; minWeight += e.w; &#125; &#125; return minWeight;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &amp;&amp; n) &#123; cin &gt;&gt; m; Graph G(n, m); G.addEdge(); cout &lt;&lt; G.Kruskal() &lt;&lt; endl; &#125; return 0;&#125; Prime算法基本思想基于贪心思想，与Dijkstra算法类似。 给定G=&lt;V,E,W&gt;，顶点个数为N 引入集合U，从顶点集V中任选一点u作为U中的元素 从顶点u的邻接点中任选一点v使这两点之间权值最小且不构成回路，将v加入U中 从顶点v出发，重复步骤(3)，直到U中元素个数为N 应用场景用于稠密图找最小生成树。 src: POJ 题意：给定无向带权图G，G中可能存在平行边。问你最小生成树所有边的权值和。 题解：Prime算法模板题，注意平行边可能权值相同，任选其一即可。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 51;class Graph&#123;private: int vertexNum; int edgeNum; int matrix[N][N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); int Prim();&#125;;void Graph::init()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; for (int j = 1; j &lt;= vertexNum; j++) &#123; matrix[i][j] = INF; &#125; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; if (matrix[u][v] &gt; w) &#123; matrix[u][v] = w; matrix[v][u] = w; &#125; &#125;&#125;int Graph::Prim()&#123; bool vis[N]; int dis[N]; for (int i = 1; i &lt;= vertexNum; i++) &#123; vis[i] = false; dis[i] = matrix[1][i]; &#125; vis[1] = true; dis[1] = INF; int minWeight = 0; for (int i = 1; i &lt;= vertexNum; i++) &#123; int k = 1; for (int j = 1; j &lt;= vertexNum; j++) &#123; if (!vis[j] &amp;&amp; dis[j] &lt; dis[k]) &#123; k = j; &#125; &#125; if (k == 1) break; vis[k] = true; minWeight += dis[k]; for (int j = 1; j &lt;= vertexNum; j++) &#123; if (!vis[j] &amp;&amp; dis[j] &gt; matrix[k][j]) &#123; dis[j] = matrix[k][j]; &#125; &#125; &#125; return minWeight;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &amp;&amp; n) &#123; cin &gt;&gt; m; Graph G(n, m); G.init(); G.addEdge(); cout &lt;&lt; G.Prim() &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的最短路径]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Dijkstra算法基本思想基于广度优先遍历思想和贪心思想。 给定G=&lt;V,E,W&gt;，指定源点s 引入集合S和集合U，S用于记录已求出最短路径的顶点以及对应的最短路径长度，U用于记录未求出最短路径的顶点以及该顶点到源点s的距离 最初S中只有源点s，U中只有除s之外的顶点 从U中找出路径最短的顶点(U中顶点的路径指s到该顶点的路径)，将其加入到S中，并更新U中的顶点和顶点的路径 重复步骤(4)，直到遍历完所有顶点 应用场景用于解决无负权边的单源最短路径问题。 src: codeforces 题意：给定无向带权图G，G中无平行边或者自环，也没有负权边。将未连通的两个顶点用虚线相连(此操作后G中实线和虚线的条数之和应为n(n-1)/2)，火车只能走实线，汽车只能走虚线。问你从1开始，分别乘火车和汽车前往n，两种方式都能抵达的最短用时，无解输出-1。 题解：Dijkstra算法模板题，各边权值均为1，注意孤立点的情况。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 401;class Graph&#123;private: int vertexNum; int edgeNum; int matrix[N][N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); void reverse(); int Dijistra();&#125;;void Graph::reverse()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; for (int j = 1; j &lt;= vertexNum; j++) &#123; if (matrix[i][j] == 1) &#123; matrix[i][j] = INF; &#125; else &#123; matrix[i][j] = 1; &#125; &#125; &#125;&#125;void Graph::init()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; for (int j = 1; j &lt;= vertexNum; j++) &#123; matrix[i][j] = INF; &#125; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; matrix[u][v] = 1; matrix[v][u] = 1; &#125;&#125;int Graph::Dijistra()&#123; bool vis[N]; int dis[N]; for (int i = 1; i &lt;= vertexNum; i++) &#123; vis[i] = false; dis[i] = matrix[1][i]; &#125; vis[1] = true; dis[1] = 0; for (int i = 2; i &lt;= vertexNum; i++) &#123; int k, min_dis = INF; for (int j = 1; j &lt;= vertexNum; j++) &#123; if (!vis[j] &amp;&amp; dis[j] &lt; min_dis) &#123; min_dis = dis[j]; k = j; &#125; &#125; if (min_dis == INF) break; vis[k] = true; for (int j = 1; j &lt;= vertexNum; j++) &#123; if (!vis[j] &amp;&amp; dis[j] &gt; dis[k] + matrix[k][j]) &#123; dis[j] = dis[k] + matrix[k][j]; &#125; &#125; &#125; return dis[vertexNum];&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Graph G(n, m); G.init(); G.addEdge(); int train = G.Dijistra(); G.reverse(); int car = G.Dijistra(); if (train == INF || car == INF) &#123; cout &lt;&lt; -1; &#125; else &#123; cout &lt;&lt; max(train, car); &#125; return 0;&#125; Floyd算法基本思想基于动态规划思想。 给定G=&lt;V,E,W&gt;，顶点个数为N 引入矩阵M，M中的元素a[i][j]表示顶点i到顶点j的距离，若i和j不相邻，则a[i][j]=∞ 对矩阵M进行N次松弛操作(类似区间DP中添加分割点k)，第k次松弛后a[i][j]将更新为只经过1~k顶点时，顶点i到顶点j的最小距离 完成N次松弛后，a[i][j]表示经过所有顶点时，顶点i到顶点j的最小距离 应用场景用于解决多源最短路径问题。 src: codeforces 题意：给定无向带权图G，G为连通图。按照一定顺序删除指定点及其所有连边。问你每次删除点之前图中现存任意两点间的距离和。 题解：Floyd算法模板题，各边权值任意，注意将删除点逆序存入后离线操作。 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 501;class Graph&#123;private: int vertexNum; int edgeNum; int matrix[N][N]; int del[N]; long long ans[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); void floyd();&#125;;void Graph::init()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; ans[i] = 0; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; for (int j = 1; j &lt;= vertexNum; j++) &#123; cin &gt;&gt; matrix[i][j]; &#125; &#125;&#125;void Graph::floyd()&#123; for (int i = vertexNum; i &gt;= 1; i--) &#123; cin &gt;&gt; del[i]; &#125; for (int k = 1; k &lt;= vertexNum; k++) &#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; for (int j = 1; j &lt;= vertexNum; j++) &#123; matrix[del[i]][del[j]] = min(matrix[del[i]][del[j]], matrix[del[i]][del[k]] + matrix[del[k]][del[j]]); if (i &lt;= k &amp;&amp; j &lt;= k) &#123; ans[k] += matrix[del[i]][del[j]]; &#125; &#125; &#125; &#125; for (int i = vertexNum; i &gt;= 1; i--) &#123; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n; m = n * (n - 1) / 2; Graph G(n, m); G.init(); G.addEdge(); G.floyd(); return 0;&#125; Bellman-Ford算法基本思想基于动态规划思想。 给定G=&lt;V,E,W&gt;，顶点个数为N，指定源点s 引入边集S，S中每个元素e有u、v、w三个属性，分别对应边的起点、终点、权值 对边集S进行N-1次松弛操作后，S中的每个元素e的权值将最小化 遍历S中的每个元素，若仍存在使得w减小的情况，则表明G中存在负权环 应用场景用于解决有负权边的单源最短路径问题。 src: POJ 题意：给定无向带权图G，向G中添加若干条有向负权边。问你G中是否存在负权环。 题解：Bellman-Ford算法模板题，注意有向边和无向边要分开讨论。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 501;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int u; int v; int w; node(int u, int v, int w) : u(u), v(v), w(w) &#123;&#125; node(); &#125;; vector&lt;node&gt; edge;public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void addEdge(int); bool Bellman_Ford();&#125;;void Graph::addEdge(int add)&#123; for (int i = 1; i &lt;= edgeNum + add; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge.push_back(node(u, v, w)); &#125;&#125;bool Graph::Bellman_Ford()&#123; int dis[N]; for (int i = 1; i &lt;= vertexNum; i++) &#123; dis[i] = INF; &#125; for (int i = 1; i &lt;= vertexNum - 1; i++) &#123; int cnt = -edgeNum; for (vector&lt;node&gt;::iterator it = edge.begin(); it != edge.end(); it++ /*auto e : edge*/) &#123; node e = *it; if (cnt++ &lt; 0) &#123; dis[e.u] = min(dis[e.u], dis[e.v] + e.w); dis[e.v] = min(dis[e.v], dis[e.u] + e.w); &#125; else &#123; dis[e.v] = min(dis[e.v], dis[e.u] - e.w); &#125; &#125; &#125; int cnt = -edgeNum; for (vector&lt;node&gt;::iterator it = edge.begin(); it != edge.end(); it++) &#123; node e = *it; if (cnt++ &lt; 0) &#123; if (dis[e.u] &gt; dis[e.v] + e.w || dis[e.v] &gt; dis[e.u] + e.w) return true; &#125; else &#123; if (dis[e.v] &gt; dis[e.u] - e.w) return true; &#125; &#125; return false;&#125;int main()&#123; int T; for (cin &gt;&gt; T; T &gt; 0; T--) &#123; int n, m, w; cin &gt;&gt; n &gt;&gt; m &gt;&gt; w; Graph G(n, m); G.addEdge(w); cout &lt;&lt; (G.Bellman_Ford() ? "YES" : "NO") &lt;&lt; endl; &#125; return 0;&#125; Spfa算法基本思想基于广度优先遍历和动态规划思想，对Bellman-Ford算法进行优化。 给定G=&lt;V,E,W&gt;，顶点个数为N，指定源点s 引入队列Q，将源点s入队 队首元素u出队，遍历u的所有出边u-&gt;v进行松弛操作，若此时v不在Q中，则将其入队 当Q非空时，重复步骤(3)，同时判断元素v入队次数是否大于N-1，若是则表明G中存在负权环 应用场景用于解决有负权边的单源最短路径问题。 src: POJ 题意：给定有向带权图G，若G中某两个顶点之间有边，一定是一对方向相反的有向边，且权值可能不同。问你G中是否存在负权环。 题解：Spfa算法模板题，注意负权环和正权环是相对的概念。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// #include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 101;class Graph&#123;private: int vertexNum; int edgeNum; struct node &#123; int v; double r; double c; node(int v, double r, double c) : v(v), r(r), c(c) &#123;&#125; node(); &#125;; vector&lt;node&gt; edge[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void addEdge(); bool Spfa(int, double);&#125;;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; double ruv, cuv, rvu, cvu; cin &gt;&gt; u &gt;&gt; v &gt;&gt; ruv &gt;&gt; cuv &gt;&gt; rvu &gt;&gt; cvu; edge[u].push_back(node(v, ruv, cuv)); edge[v].push_back(node(u, rvu, cvu)); &#125;&#125;bool Graph::Spfa(int s, double v)&#123; double dis[N]; int cnt[N]; bool vis[N]; for (int i = 1; i &lt;= vertexNum; i++) &#123; dis[i] = 0; cnt[i] = 0; vis[i] = false; &#125; dis[s] = v; cnt[s]++; vis[s] = true; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (vector&lt;node&gt;::iterator it = edge[u].begin(); it != edge[u].end(); it++ /*auto e : edge[u]*/) &#123; node e = *it; if (dis[e.v] &lt; (dis[u] - e.c) * e.r) &#123; dis[e.v] = (dis[u] - e.c) * e.r; if (!vis[e.v]) &#123; vis[e.v] = true; q.push(e.v); cnt[e.v]++; if (cnt[e.v] &gt; vertexNum - 1) return true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; int n, m, s; double v; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; v; Graph G(n, m); G.addEdge(); cout &lt;&lt; (G.Spfa(s, v) ? "YES" : "NO") &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>Floyd</tag>
        <tag>Bellman-Ford</tag>
        <tag>Spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的遍历]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[图的深度优先遍历基本思想 给定G=&lt;V,E&gt;，假定初始状态为G中所有顶点均未被访问，以一个未被访问过的顶点为起始点，依次访问各个未被访问的邻接点，直到G中所有和顶点v连通的顶点都被访问。 若经过(1)的操作后G中尚有其他顶点未被访问，则另选一个未被访问的顶点作为起始点，重复步骤(1)，直到G中所有顶点均被访问。 应用无向图找环src: codeforces 题意：给定无向图G，G中每个顶点度数不小于k。要你找到一个长度大于k的环(保证答案存在)。 题解：考虑深度优先遍历。遍历过程中，对于一条边u-&gt;v: vis[v] = 0 表示v未被访问，u-&gt;v是一条树边 vis[v] = 1 表示v已被访问，但其子孙未被访问完，u-&gt;v是一条后向边(返祖边) vis[v] = 2 表示v已被访问，且其子孙已被访问完，u-&gt;v是一条前向边或者横叉边 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100001;class Graph&#123;private: int vertexNum; int edgeNum; int minDegree; vector&lt;int&gt; edge[N]; vector&lt;int&gt; path; int dis[N]; bool vis[N]; bool flag;public: Graph(int n, int m, int k) : vertexNum(n), edgeNum(m), minDegree(k) &#123;&#125; void init(); void addEdge(); void findCircle(int, int);&#125;;void Graph::init()&#123; flag = false; for(int i = 1 ; i &lt;= vertexNum ;i++)&#123; vis[i] = false; dis[i] = 0; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; edge[u].push_back(v); edge[v].push_back(u); &#125;&#125;void Graph::findCircle(int u = 1, int d = 0)&#123; if (vis[u] == 1) return; vis[u] = true; dis[u] = d; path.push_back(u); for (auto v : edge[u]) &#123; if (flag) return; if (vis[v] == true &amp;&amp; d - dis[v] &gt;= minDegree) &#123; int pos = 0; while (path[pos] != v) &#123; pos++; &#125; cout &lt;&lt; d - dis[v] + 1 &lt;&lt; endl; for (int i = pos; i &lt;= d; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; ' '; &#125; flag = true; &#125; else &#123; findCircle(v, d + 1); &#125; &#125; vis[u] = 2; path.pop_back();&#125;int main()&#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; Graph G(n, m, k); G.init(); G.addEdge(); G.findCircle(); return 0;&#125; 无向图的k着色问题src: luogu 题意：给定无向图G和颜色种类k。问你用k种颜色对G中所有顶点着色，使得每条边连接的两个顶点着色不同的方案数。 题解：考虑深度优先遍历。遍历所有顶点，着色后判重，若重复则回溯，否则继续。 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 101;class Graph&#123;private: int vertexNum; int edgeNum; int colorNum; int matrix[N][N]; int color[N]; int sum;public: Graph(int n, int m, int k) : vertexNum(n), edgeNum(m), colorNum(k) &#123; sum = 0; &#125; void addEdge(); void kColoring(int); bool checkColor(int); int getSum() &#123; return sum; &#125;&#125;;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; matrix[u][v] = 1; matrix[v][u] = 1; &#125;&#125;bool Graph::checkColor(int i)&#123; for (int j = 1; j &lt; i; j++) &#123; if (matrix[i][j] == 1 &amp;&amp; color[i] == color[j]) return false; &#125; return true;&#125;void Graph::kColoring(int i = 1)&#123; if (i &gt; vertexNum) &#123; sum++; /*for (int j = 1; j &lt;= vertexNum; j++) &#123; cout &lt;&lt; color[j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl;*/ return; &#125; else &#123; for (int j = 1; j &lt;= colorNum; j++) &#123; color[i] = j; if (checkColor(i)) &#123; kColoring(i + 1); &#125; &#125; &#125;&#125;int main()&#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; Graph G(n, m, k); G.addEdge(); G.kColoring(); cout &lt;&lt; G.getSum() &lt;&lt; endl; return 0;&#125; 图的广度优先遍历基本思想给定G=&lt;V,E&gt;，假定初始状态为G中所有顶点均未被访问，以一个未被访问过的顶点为起始点，分别访问各个邻接点的邻接点，直到G中所有和顶点v连通的顶点都被访问。 应用无向图找最小字典序src: codeforces 题意：给定无向图G，G中可能存在平行边或者自环。要你找到遍历所有顶点的最小字典序。 题解：考虑广度优先遍历。直接使用最小堆，利用标记数组判重即可。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100001;class Graph&#123;private: int vertexNum; int edgeNum; vector&lt;int&gt; edge[N]; bool vis[N];public: Graph(int n, int m) : vertexNum(n), edgeNum(m) &#123;&#125; void init(); void addEdge(); void findMinDicOrd();&#125;;void Graph::init()&#123; for (int i = 1; i &lt;= vertexNum; i++) &#123; vis[i] = false; &#125;&#125;void Graph::addEdge()&#123; for (int i = 1; i &lt;= edgeNum; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; edge[u].push_back(v); edge[v].push_back(u); &#125;&#125;void Graph::findMinDicOrd()&#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; p; p.push(1); while (!p.empty()) &#123; int u = p.top(); p.pop(); if (vis[u]) continue; vis[u] = true; cout &lt;&lt; u &lt;&lt; " "; for (auto v : edge[u]) &#123; if (!vis[v]) &#123; p.push(v); &#125; &#125; &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; Graph G(n, m); G.addEdge(); G.init(); G.findMinDicOrd(); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>Algorithm - Graph Theory</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
</search>
