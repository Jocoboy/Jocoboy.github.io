<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unity即时模式GUI]]></title>
    <url>%2F2020%2F01%2F10%2FUnity-UI-IMGUI%2F</url>
    <content type="text"><![CDATA[123Unity’s IMGUI controls make use of a special function called OnGUI(). The OnGUI() function gets called every frame as long as the containing script is enabled - just like the Update() function. Unity的IMGUI控件使用一个名为OnGUI()的特殊函数。只要启用包含的脚本，就会在每帧调用OnGUI()函数，就像Update()函数一样。 IMGUI控件控件类型 Label: 12The Label is non-interactive. It is for display only. It cannot be clicked or otherwise moved. It is best for displaying information only. Label为非交互式控件。此控件仅用于显示目的。不能单击，也不能以其他方式进行移动。此控件最适合于纯粹显示信息之用。 Button: 12The Button is a typical interactive button. It will respond a single time when clicked, no matter how long the mouse remains depressed. The response occurs as soon as the mouse button is released. Button是典型的交互式按钮。点击按钮时，无论鼠标按下多久，都只会响应一次。松开鼠标按键后会立即响应。 RepeatButton: 123RepeatButton is a variation of the regular Button. The difference is, RepeatButton will respond every frame that the mouse button remains depressed. This allows you to create click-and-hold functionality. RepeatButton是常规Button的变体。区别在于，RepeatButton将响应鼠标按键保持按下状态的每一帧。由此可以创建单击并保持功能(例如，射击连发功能）。 TextField: 1The TextField Control is an interactive, editable single-line field containing a text string. TextField控件是一个包含文本字符串的交互式可编辑单行字段。 TextArea: 1The TextArea Control is an interactive, editable multi-line area containing a text string. TextArea控件是一个包含文本字符串的交互式可编辑多行区域。 Toggle: 12The Toggle Control creates a checkbox with a persistent on/off state. The user can change the state by clicking on it. Toggle控件创建具有持久开/关状态的复选框。用户可通过点击该复选框来更改状态。 Toolbar: 1234The Toolbar Control is essentially a row of Buttons. Only one of the Buttons on the Toolbar can be active at a time, and it will remain active until a different Button is clicked. This behavior emulates the behavior of a typical Toolbar. You can define an arbitrary number of Buttons on the Toolbar. Toolbar控件本质上是一行Button。在Toolbar上，一次只能有一个Button处于激活状态，并且此Button将一直保持激活状态，直到点击其他Button。此行为模拟典型Toolbar的行为。在Toolbar上可以定义任意数量的Button。 SelectionGrid: 12The SelectionGrid Control is a multi-row Toolbar. You can determine the number of columns and rows in the grid. Only one Button can be active at time. SelectionGrid控件是一种多行Toolbar。您可以决定网格中的列数和行数。一次只能激活一个Button。 HorizontalSlider: 12The HorizontalSlider Control is a typical horizontal sliding knob that can be dragged to change a value between predetermined min and max values. HorizontalSlider控件是一个典型的水平滑钮，可拖动该滑钮来更改介于预定最小值和最大值之间的值。 VerticalSlider: 12The VerticalSlider Control is a typical vertical sliding knob that can be dragged to change a value between predetermined min and max values. VerticalSlider控件是一个典型的垂直滑钮，可拖动该滑钮来更改介于预定最小值和最大值之间的值。 HorizontalScrollbar: 123The HorizontalScrollbar Control is similar to a Slider Control, but visually similar to Scrolling elements for web browsers or word processors. This control is used to navigate the ScrollView Control. HorizontalScrollbar控件类似于Slider控件，但在视觉上类似于Web浏览器或文字处理程序的滚动元素。此控件用于导航 ScrollView 控件。 VerticalScrollbar: 123The VerticalScrollbar Control is similar to a Slider Control, but visually similar to Scrolling elements for web browsers or word processors. This control is used to navigate the ScrollView Control. VerticalScrollbar控件类似于Slider控件，但在视觉上类似于Web浏览器或文字处理程序的滚动元素。此控件用于导航 ScrollView 控件。 ScrollView: 1ScrollViews are Controls that display a viewable area of a much larger set of Controls. ScrollView控件可显示一个包含更大控件集合的可视区域。 Window: 1234Windows are drag-able containers of Controls. They can receive and lose focus when clicked. Because of this, they are implemented slightly differently from the other Controls. Each Window has an id number, and its contents are declared inside a separate function that is called when the Window has focus. Window是可拖动的控件容器。点击时，Window可获得和失去焦点。因此，实现方式与其他控件略有不同。每个Window都有一个 id编号，并且其内容在一个单独的函数内声明，该函数在Window获得焦点时调用。 控件测试为一个GameObject添加IMGUIControls脚本实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104using UnityEngine;/// &lt;summary&gt;/// A simple demo for IMGUI Controls./// &lt;summary&gt;public class IMGUIControls : MonoBehaviour&#123; private string textFieldString = "The TextField Control is an interactive, editable single-line field containing a text string."; private string textAreaString = "The TextArea Control is an interactive, editable multi-line area containing a text string."; private bool toggleBool = true; private int toolbarInt = 0; private readonly string[] toolbarStrings = &#123; "Toolbar 1", "Toolbar 2", "Toolbar 3" &#125;; private int selectionGridInt = 0; private readonly string[] selectionStrings = &#123; "Grid 1", "Grid 2", "Grid 3", "Grid 4", "Grid 5" &#125;; private float hSliderValue = 0.0f; private float vSliderValue = 0.0f; private float hScrollbarValue; private float vScrollbarValue; private Vector2 scrollViewVector = Vector2.zero; private string innerText = "ScrollViews are Controls that display a viewable area of a much larger set of Controls."; private Rect windowRect = new Rect(220, 240, 200, 50); private void WindowFunction(int windowID) &#123; //print("WindowFunction called"); &#125; private void OnGUI() &#123; GUI.Label(new Rect(10, 10, 200, 20), "Label"); // In UnityGUI, Buttons will return true when they are clicked. if (GUI.Button(new Rect(10, 40, 200, 50), "Button")) &#123; print("Button"); &#125; // In UnityGUI, RepeatButtons will return true for every frame that they are clicked. if (GUI.RepeatButton(new Rect(10, 110, 200, 50), "RepeatButton")) &#123; print("RepeatButton"); &#125; // When edits are made to the string, the TextField function will return the edited string. textFieldString = GUI.TextField(new Rect(10, 170, 200, 50), textFieldString); // When edits are made to the string, the TextArea function will return the edited string. textAreaString = GUI.TextArea(new Rect(10, 230, 200, 50), textAreaString); // The Toggle function will return a new boolean value if it is clicked. // In order to capture this interactivity, you must assign the boolean to accept the return value of the Toggle function. toggleBool = GUI.Toggle(new Rect(10, 280, 200, 30), toggleBool, "Toggle"); // To make the Toolbar interactive, you must assign the integer to the return value of the function. // The number of elements in the content array that you provide will determine the number of Buttons that are shown in the Toolbar. toolbarInt = GUI.Toolbar(new Rect(10, 310, 200, 50), toolbarInt, toolbarStrings); // To make the SelectionGrid interactive, you must assign the integer to the return value of the function. // The number of elements in the content array that you provide will determine the number of Buttons that are shown in the SelectionGrid. selectionGridInt = GUI.SelectionGrid(new Rect(10, 360, 200, 60), selectionGridInt, selectionStrings, 3); hSliderValue = GUI.HorizontalSlider(new Rect(220, 10, 100, 30), hSliderValue, 0.0f, 10.0f); vSliderValue = GUI.VerticalSlider(new Rect(220, 30, 100, 30), vSliderValue, 10.0f, 0.0f); hScrollbarValue = GUI.HorizontalScrollbar(new Rect(220, 70, 100, 30), hScrollbarValue, 1.0f, 0.0f, 10.0f); vScrollbarValue = GUI.VerticalScrollbar(new Rect(220, 90, 100, 30), vScrollbarValue, 1.0f, 10.0f, 0.0f); // ScrollViews require two Rects as arguments. // The first Rect defines the location and size of the viewable ScrollView area on the screen. // The second Rect defines the size of the space contained inside the viewable area. // If the space inside the viewable area is larger than the viewable area, Scrollbars will appear as appropriate. // You must also assign and provide a 2D Vector which stores the position of the viewable area that is displayed. scrollViewVector = GUI.BeginScrollView(new Rect(220, 130, 250, 100), scrollViewVector, new Rect(0, 0, 400, 400)); innerText = GUI.TextArea(new Rect(0, 0, 400, 400), innerText); GUI.EndScrollView(); windowRect = GUI.Window(0, windowRect, WindowFunction, "My Window"); // To detect if the user did any action in the GUI (clicked a button, dragged a slider, etc), read the GUI.changed value from your script. // This gets set to true when the user has done something, making it easy to validate the user input. if (GUI.changed) &#123; print("The toolbar was clicked"); switch (toolbarInt) &#123; case 0: print("First button was clicked"); break; case 1: print("Second button was clicked"); break; case 2: print("Third button was clicked"); break; &#125; &#125; &#125;&#125; IMGUI布局模式1234Depending on which Layout Mode you’re using, there are different hooks for controlling where your Controls are positioned and how they are grouped together. In Fixed Layout, you can put different Controls into Groups. In Automatic Layout, you can put different Controls into Areas, Horizontal Groups, and Vertical Groups. 根据使用的布局模式，可通过不同的挂钩来控制控件的位置以及控件如何组合在一起。在固定布局中，可将不同的控件放入组中。在自动布局中，可将不同的控件放入区域、水平组和垂直组中。 固定布局 Fixed Layout - Groups: 12345Groups are a convention available in Fixed Layout Mode. They allow you to define areas of the screen that contain multiple Controls. You define which Controls are inside a Group by using the GUI.BeginGroup() and GUI.EndGroup() functions. All Controls inside a Group will be positioned based on the Group’s top-left corner instead of the screen’s top-left corner. This way, if you reposition the group at runtime, the relative positions of all Controls in the group will be maintained. 组是固定布局模式中的布局规则。使用组可以定义包含多个控件的屏幕区域。为定义组中包含的控件，需要使用 GUI.BeginGroup()和GUI.EndGroup()函数。组内的所有控件将根据组的左上角而不是屏幕的左上角进行定位。因此，如果在运行时重新定位组，则将保持组中所有控件的相对位置。 自动布局 Automatic Layout - Areas: 12345678Areas are used in Automatic Layout mode only. They are similar to Fixed Layout Groups in functionality, as they define a finite portion of the screen to contain GUILayout Controls. Because of the nature of Automatic Layout, you will nearly always use Areas.In Automatic Layout mode, you do not define the area of the screen where the Control will be drawn at the Control level. The Control will automatically be placed at the upper-leftmost point of its containing area. This might be the screen. You can also create manually-positioned Areas. GUILayout Controls inside an area will be placed at the upper-leftmost point of that area. 区域仅用于自动布局模式。区域定义了有限的屏幕区域来包含 GUILayout 控件，因此在功能上类似于固定布局组。由于自动布局的性质，几乎始终要用到区域。 在自动布局模式下，不需要在控制级别定义绘制控件的屏幕区域。控件将自动放置在包含该控件的区域的最左上角。此区域可能是指屏幕。此外也可以创建手动定位的区域。一个区域内的GUILayout控件将放置在该区域的最左上角。 Automatic Layout - Horizontal and Vertical Groups: 12345678910111213When using Automatic Layout, Controls will by default appear one after another from top to bottom. There are plenty of occasions you will want finer level of control over where your Controls are placed and how they are arranged. If you are using the Automatic Layout mode, you have the option of Horizontal and Vertical Groups.Like the other layout Controls, you call separate functions to start or end these groups. The specific functions are GUILayout.BeginHorizontal(), GUILayout.EndHorizontal(), GUILayout.BeginVertical(), and GUILayout.EndVertical().Any Controls inside a Horizontal Group will always be laid out horizontally. Any Controls inside a Vertical Group will always be laid out vertically. This sounds plain until you start nesting groups inside each other. This allows you to arrange any number of controls in any imaginable configuration. 使用自动布局时，默认情况下控件将从上到下依次出现。在很多情况下，需要更精确控制控件的放置位置以及排列方式。如果使用自动布局模式，则可以选择水平和垂直组。 与其他布局控件一样，可以调用单独的函数来开始或结束这些组。这些函数为 GUILayout.BeginHoriztontal()、GUILayout.EndHorizontal()、GUILayout.BeginVertical() 和 GUILayout.EndVertical()。 水平组内的所有控件都将始终采用水平布局方式。垂直组内的所有控件都将始终采用垂直布局方式。这听起来很简单，但若要将组嵌套在彼此内部，就不那么简单了。通过嵌套的方式可在任何能够想象的配置中排列任意数量的控件。 布局测试为一个GameObject添加IMGUILayoutModes脚本实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using UnityEngine;/// &lt;summary&gt;/// A simple demo for IMGUI Layout Modes./// &lt;summary&gt;public class IMGUILayoutModes : MonoBehaviour&#123; public Texture2D bgImage; public Texture2D fgImage; public float playerEnergy = 1.0f; private float sliderValue = 1.0f; private float maxSliderValue = 10.0f; private void OnGUI() &#123; // You define which Controls are inside a Group by using the GUI.BeginGroup() and GUI.EndGroup() functions. GUI.BeginGroup(new Rect(Screen.width / 2 - 50, Screen.height / 2 - 50, 100, 100)); GUI.Box(new Rect(0, 0, 100, 100), "Group is here"); GUI.Button(new Rect(10, 40, 80, 30), "Click me"); GUI.EndGroup(); // You can also nest multiple Groups inside each other. // When you do this, each group has its contents clipped to its parent’s space. GUI.BeginGroup(new Rect(Screen.width / 2 -128 ,Screen.height / 2 +116, 256, 32)); GUI.Box(new Rect(0, 0, 256, 32), bgImage); GUI.BeginGroup(new Rect(0, 0, playerEnergy * 256, 32)); GUI.Box(new Rect(0, 0, 256, 32), fgImage); GUI.EndGroup(); GUI.EndGroup(); GUILayout.Button("I am not inside an Area"); GUILayout.BeginArea(new Rect(0, Screen.height / 2, 300, 300)); // Notice that inside an Area, Controls with visible elements like Buttons and Boxes will stretch their width to the full length of the Area. GUILayout.Button("I am a regular Automatic Layout Button"); // You can use GUILayoutOptions to override some of the Automatic Layout parameters. // You do this by providing the options as the final parameters of the GUILayout Control. GUILayout.Button("My width has been overridden", GUILayout.Width(200)); GUILayout.EndArea(); // Using nested Horizontal and Vertical Groups. GUILayout.BeginArea(new Rect(0, 400, 200, 60)); GUILayout.BeginHorizontal(); if (GUILayout.RepeatButton("Increase max\nSlider Value")) &#123; maxSliderValue += 3.0f * Time.deltaTime; &#125; GUILayout.BeginVertical(); GUILayout.Box("Slider Value: " + Mathf.Round(sliderValue)); sliderValue = GUILayout.HorizontalSlider(sliderValue, 0.0f, maxSliderValue); GUILayout.EndVertical(); GUILayout.EndHorizontal(); GUILayout.EndArea(); &#125;&#125; 官方文档Immediate Mode GUI (IMGUI)]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Unity-UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity自定义天空盒]]></title>
    <url>%2F2020%2F01%2F06%2FUnity-Graphics-Skybox%2F</url>
    <content type="text"><![CDATA[1A Skybox is a six-sided cube that Unity draws behind all graphics in the Scene. 一个天空盒是一个六面立方体，会将游戏场景中的所有图形包裹。 自定义天空盒6-sided准备6张TIFF/TIF格式(具有跨平台性)的方位局部图，1024×1024px。 创建步骤 创建与天空盒六个面相对应的六个纹理，将它们放在项目的Assets文件夹中。12Make six Textures that correspond to each of the six sides of the skybox, and put them into yourProject’s Assets folder. 对于每个纹理，需要将包裹模式从Repeat更改为Clamp。如果不这样做，边缘上的颜色将不匹配。12For each Texture, you need to change the wrap mode from Repeat to Clamp.If you don’t do this, colors on the edges do not match up. 从菜单栏中选择Assets &gt; Create &gt; Material以创建新材质。 1Create a new Material. To do this, choose Assets &gt; Create &gt; Material from the menu bar. 在Inspector面板的顶部选择Shader下拉选单，然后选择Skybox/6 Sided。 1Select the Shader drop-down and choose Skybox/6 Sided. 将6个纹理分配给材质中的每个纹理字段。为此，可将每个纹理从Project面板拖放到相应的字段上。 12Assign the six Textures to each Texture slot in the Material. To do this, you can drag each Texture from the Project View onto the corresponding slots. 最后，将天空盒分配给当前场景，须执行以下操作： 在菜单栏中选择Window &gt; Rendering &gt; Lighting Settings。 在随后出现的窗口中选择Scene选项卡。 将新的天空盒材质拖放到Skybox字段。12345To assign the skybox to the Scene you’re working on:- From the menu bar, choose Window &gt; Rendering &gt; Lighting Settings.- In the window that appears, select the Scene tab.- Drag the new Skybox Material to the Skybox slot. panoramic准备1张png格式的（360°/720°）全景图，2048×1024px/4096×2048px。 创建步骤步骤1~3及步骤6同6-sided。 在Inspector面板的顶部选择Shader下拉选单，然后选择Skybox/Panoramic。 1Select the Shader drop-down and choose Skybox/Panoramic. 为材质选择一个球状纹理。 1Assign a Spherical Texture to the Material. 官方文档How do I Make a Skybox?]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Unity-Graphics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity脚本生命周期]]></title>
    <url>%2F2020%2F01%2F04%2FUnity-Script-Lifecycle%2F</url>
    <content type="text"><![CDATA[1Running a Unity script executes a number of event functions in a predetermined order. 一个Unity脚本中的事件函数将会以预定顺序执行。 脚本生命周期流程图下图总结了脚本生命周期中事件函数的排序和重复出现情况。 说明 Awake: 1This function is always called before any Start functions and also just after a prefab is instantiated. 此函数将在预制件实例化之后调用，并始终优先于任何Start函数。 OnEnable: 123This function is called just after the object is enabled. This happens when a MonoBehaviour instance is created, such as when a level is loaded or a GameObject with the script component is instantiated. 此函数将在启用对象后立即调用。在创建MonoBehaviour实例时（例如加载关卡或一个携带脚本组件的游戏对象被实例化时）会执行此调用。 Reset: 12Reset is called to initialize the script’s properties when it is first attached to the objectand also when the Reset command is used. 此函数将在脚本首次被附加到对象上以及使用Reset命令时调用，以初始化脚本的属性。 Start: 1Start is called before the first frame update only if the script instance is enabled. 此函数将紧跟Awake函数调用，确切来说是在第一此帧更新前并且此时脚本实例已被启用。 FixedUpdate: 1234567FixedUpdate is often called more frequently than Update. It can be called multiple times per frame, if the frame rate is low and it may not be called between frames at all if the frame rate is high. All physics calculations and updates occur immediately after FixedUpdate. When applying movement calculations inside FixedUpdate, you do not need to multiply your values by Time.deltaTime. This is because FixedUpdate is called on a reliable timer, independent of the frame rate. 调用FixedUpdate的频度常常超过Update。如果帧率很低，可以每帧调用该函数多次；如果帧率很高，可能在帧之间完全不调用该函数。在FixedUpdate之后将立即进行所有物理计算和更新。在FixedUpdate内应用运动计算时，无需将值乘以 Time.deltaTime。这是因为FixedUpdate的调用基于可靠的计时器（独立于帧率）。 Update: 1Update is called once per frame. It is the main workhorse function for frame updates. 此函数是帧更新的主函数，受当前渲染物体和机器性能影响，被调用的时间间隔不固定。 Coroutines： 12345678910Normal coroutine updates are run after the Update function returns. A coroutine is a function that can suspend its execution (yield) until the given YieldInstruction finishes. Different uses of Coroutines:- yield The coroutine will continue after all Update functions have been called on the next frame.- yield WaitForSeconds Continue after a specified time delay, after all Update functions have been called for the frame- yield WaitForFixedUpdate Continue after all FixedUpdate has been called on all scripts- yield WWW Continue after a WWW download has completed.- yield StartCoroutine Chains the coroutine, and will wait for the MyFunc coroutine to complete first. Update函数返回后将运行正常协程更新。协程是一个可暂停执行(yield)直到给定的YieldInstruction达到完成状态的函数。协程的不同用法： yield 协程将在下一帧上调用所有Update函数后，继续执行。 yield WaitForSeconds 协程将在指定的时间延迟后（并且当前帧所有Update函数执行后），继续执行。 yield WaitForFixedUpdate 协程将在所有脚本的FixedUpdate函数执行后，继续执行。 yield WWW 协程将在WWW资源下载完成后，继续执行。 yield StartCoroutine 协程将在指定协程执行后，继续执行。 LateUpdate: 1LateUpdate is called once per frame, after Update has finished. 此函数将紧跟Update函数调用，通常用于伴随逻辑的跟踪。 OnApplicationPause 123This is called at the end of the frame where the pause is detected, effectively between the normal frame updates. One extra frame will be issued after OnApplicationPause is called to allow the game to show graphics that indicate the paused state. 在帧的结尾处调用此函数（在正常帧更新之间有效检测到暂停）。在调用OnApplicationPause之后，将发出一个额外帧，从而允许游戏显示图形来指示暂停状态。 OnApplicationQuit: 12This function is called on all game objects before the application is quit. In the editor it is called when the user stops playmode. 此函数将在应用退出之前调用，例如在Editor中再次点击Play按钮关闭播放模式。 OnDisable: 1This function is called when the behaviour becomes disabled or inactive. 此函数将在行为被禁用或处于非活动状态时调用，例如OnApplicationQuit函数调用之后。 OnDestroy: 12This function is called after all frame updates for the last frame of the object’s existence (the object might be destroyed in response to Object.Destroy or at the closure of a scene). 此函数将在对象存在的最后一帧完成所有帧更新之后调用，可能应Object.Destroy函数要求或在场景关闭时销毁该对象。 函数执行顺序测试（以下测试不包含协程函数）为一个Cube物体添加Lifecycle脚本组件。 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using UnityEngine;/// &lt;summary&gt;/// Simple demo for script lifecycle ./// &lt;summary&gt;public class Lifecycle : MonoBehaviour&#123; private void Awake() &#123; Debug.Log("Function : Awake() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void OnEnable() &#123; Debug.Log("Function : OnEnable() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void Reset() &#123; Debug.Log("Function : Reset() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void Start() &#123; Debug.Log("Function : Start() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void FixedUpdate() &#123; if (Time.time &lt; 0.1) &#123; Debug.Log("Function : FixedUpdate() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; // private void OnMouseDown() // &#123; // Debug.Log("Function : OnMouseDown() " + "Time : " + Time.time + " Object.name : " + this.name); // &#125; private void Update() &#123; if (Time.time &lt; 0.1) &#123; Debug.Log("Function : Update() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; private void LateUpdate() &#123; if (Time.time &lt; 0.1) &#123; Debug.Log("Function : LateUpdate() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; // private void OnGUI() // &#123; // if (Time.time &lt; 0.1) // &#123; // Debug.Log("Function : OnGUI() " + "Time : " + Time.time + " Object.name : " + this.name); // &#125; // &#125; private void OnApplicationPause(bool pause = true) &#123; if (pause) &#123; Debug.Log("Function : OnApplicationPause() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; &#125; private void OnApplicationQuit() &#123; Debug.Log("Function : OnApplicationQuit() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; private void OnDisable() &#123; Debug.Log("Function : OnDisable() " + "Time : " + Time.time + " Object.name : " + this.name); &#125; public void OnDestroy() &#123; Debug.Log("Function : OnDestroy() " + "Time : " + Time.time + " Object.name : " + this.name); &#125;&#125; 测试结果 测试反馈控制台输出结果表明，运行场景时在Editor中点击Pause按钮将不会调用OnApplicationPause函数。 官方文档Order of Execution for Event Functions]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Unity-Scripting</tag>
      </tags>
  </entry>
</search>
